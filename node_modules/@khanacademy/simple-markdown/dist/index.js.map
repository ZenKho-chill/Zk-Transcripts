{"version":3,"file":"index.js","sources":["../src/version.ts","../src/index.ts"],"sourcesContent":["// This file is processed by a Rollup plugin (replace) to inject the production\n// version number during the release build.\n// In dev, you'll never see the version number.\n\nimport {addLibraryVersionToPerseusDebug} from \"@khanacademy/perseus-core\";\n\nconst libName = \"@khanacademy/simple-markdown\";\nexport const libVersion = \"__lib_version__\";\n\naddLibraryVersionToPerseusDebug(libName, libVersion);\n","/* eslint-disable prefer-spread, no-regex-spaces, guard-for-in, no-console, no-var */\n/**\n * Simple-Markdown\n * ===============\n *\n * Simple-Markdown's primary goal is to be easy to adapt. It aims\n * to be compliant with John Gruber's [Markdown Syntax page][1],\n * but compatiblity with other markdown implementations' edge-cases\n * will be sacrificed where it conflicts with simplicity or\n * extensibility.\n *\n * If your goal is to simply embed a standard markdown implementation\n * in your website, simple-markdown is probably not the best library\n * for you (although it should work). But if you have struggled to\n * customize an existing library to meet your needs, simple-markdown\n * might be able to help.\n *\n * Many of the regexes and original logic has been adapted from\n * the wonderful [marked.js](https://github.com/chjj/marked)\n */\nimport type {Capture, MatchFunction, State} from \"./troublesome-types\";\nimport type * as React from \"react\";\n\nexport {libVersion} from \"./version\";\n\n// Type Definitions:\n\ntype Attr = string | number | boolean | null | undefined;\n\ntype SingleASTNode = {\n    type: string;\n    [key: string]: any;\n};\n\ntype UnTypedASTNode = {\n    [key: string]: any;\n};\n\ntype ASTNode = SingleASTNode | Array<SingleASTNode>;\n\ntype ReactElement = React.ReactElement<any>;\ntype ReactElements = React.ReactNode;\n\ntype Parser = (\n    source: string,\n    state?: State | null | undefined,\n) => Array<SingleASTNode>;\n\ntype ParseFunction = (\n    capture: Capture,\n    nestedParse: Parser,\n    state: State,\n) => UnTypedASTNode | ASTNode;\n\ntype SingleNodeParseFunction = (\n    capture: Capture,\n    nestedParse: Parser,\n    state: State,\n) => UnTypedASTNode;\n\ntype Output<Result> = (\n    node: ASTNode,\n    state?: State | null | undefined,\n) => Result;\n\ntype NodeOutput<Result> = (\n    node: SingleASTNode,\n    nestedOutput: Output<Result>,\n    state: State,\n) => Result;\n\ntype ArrayNodeOutput<Result> = (\n    node: Array<SingleASTNode>,\n    nestedOutput: Output<Result>,\n    state: State,\n) => Result;\n\ntype ReactOutput = Output<ReactElements>;\ntype ReactNodeOutput = NodeOutput<ReactElements>;\ntype HtmlOutput = Output<string>;\ntype HtmlNodeOutput = NodeOutput<string>;\n\ntype ParserRule = {\n    readonly order: number;\n    readonly match: MatchFunction;\n    readonly quality?: (\n        capture: Capture,\n        state: State,\n        prevCapture: string,\n    ) => number;\n    readonly parse: ParseFunction;\n};\n\ntype SingleNodeParserRule = {\n    readonly order: number;\n    readonly match: MatchFunction;\n    readonly quality?: (\n        capture: Capture,\n        state: State,\n        prevCapture: string,\n    ) => number;\n    readonly parse: SingleNodeParseFunction;\n};\n\ntype ReactOutputRule = {\n    // we allow null because some rules are never output results, and that's\n    // legal as long as no parsers return an AST node matching that rule.\n    // We don't use ? because this makes it be explicitly defined as either\n    // a valid function or null, so it can't be forgotten.\n    readonly react: ReactNodeOutput | null;\n};\n\ntype HtmlOutputRule = {\n    readonly html: HtmlNodeOutput | null;\n};\n\ntype ArrayRule = {\n    // @ts-expect-error - TS2411 - Property 'react' of type 'ArrayNodeOutput<ReactNode> | undefined' is not assignable to 'string' index type 'ArrayNodeOutput<any>'.\n    readonly react?: ArrayNodeOutput<ReactElements>;\n    // @ts-expect-error - TS2411 - Property 'html' of type 'ArrayNodeOutput<string> | undefined' is not assignable to 'string' index type 'ArrayNodeOutput<any>'.\n    readonly html?: ArrayNodeOutput<string>;\n    readonly [key: string]: ArrayNodeOutput<any>;\n};\n\ntype ParserRules = {\n    // @ts-expect-error - TS2411 - Property 'Array' of type 'ArrayRule | undefined' is not assignable to 'string' index type 'ParserRule'.\n    readonly Array?: ArrayRule;\n    readonly [type: string]: ParserRule;\n};\n\ntype OutputRules<Rule> = {\n    // @ts-expect-error - TS2411 - Property 'Array' of type 'ArrayRule | undefined' is not assignable to 'string' index type 'Rule'.\n    readonly Array?: ArrayRule;\n    readonly [type: string]: Rule;\n};\ntype Rules<OutputRule> = {\n    // @ts-expect-error - TS2411 - Property 'Array' of type 'ArrayRule | undefined' is not assignable to 'string' index type 'ParserRule & OutputRule'.\n    readonly Array?: ArrayRule;\n    readonly [type: string]: ParserRule & OutputRule;\n};\ntype ReactRules = {\n    // @ts-expect-error - TS2411 - Property 'Array' of type '{ readonly react: ArrayNodeOutput<ReactNode>; } | undefined' is not assignable to 'string' index type 'ParserRule & ReactOutputRule'.\n    readonly Array?: {\n        readonly react: ArrayNodeOutput<ReactElements>;\n    };\n    readonly [type: string]: ParserRule & ReactOutputRule;\n};\ntype HtmlRules = {\n    // @ts-expect-error - TS2411 - Property 'Array' of type '{ readonly html: ArrayNodeOutput<string>; } | undefined' is not assignable to 'string' index type 'ParserRule & HtmlOutputRule'.\n    readonly Array?: {\n        readonly html: ArrayNodeOutput<string>;\n    };\n    readonly [type: string]: ParserRule & HtmlOutputRule;\n};\n\n// We want to clarify our defaultRules types a little bit more so clients can\n// reuse defaultRules built-ins. So we make some stronger guarantess when\n// we can:\ntype NonNullReactOutputRule = {\n    readonly react: ReactNodeOutput;\n};\ntype ElementReactOutputRule = {\n    readonly react: NodeOutput<ReactElement>;\n};\ntype TextReactOutputRule = {\n    readonly react: NodeOutput<string>;\n};\ntype NonNullHtmlOutputRule = {\n    readonly html: HtmlNodeOutput;\n};\n\ntype DefaultInRule = SingleNodeParserRule & ReactOutputRule & HtmlOutputRule;\ntype TextInOutRule = SingleNodeParserRule &\n    TextReactOutputRule &\n    NonNullHtmlOutputRule;\ntype LenientInOutRule = SingleNodeParserRule &\n    NonNullReactOutputRule &\n    NonNullHtmlOutputRule;\ntype DefaultInOutRule = SingleNodeParserRule &\n    ElementReactOutputRule &\n    NonNullHtmlOutputRule;\n\ntype DefaultRules = {\n    readonly Array: {\n        readonly react: ArrayNodeOutput<ReactElements>;\n        readonly html: ArrayNodeOutput<string>;\n    };\n    readonly heading: DefaultInOutRule;\n    readonly nptable: DefaultInRule;\n    readonly lheading: DefaultInRule;\n    readonly hr: DefaultInOutRule;\n    readonly codeBlock: DefaultInOutRule;\n    readonly fence: DefaultInRule;\n    readonly blockQuote: DefaultInOutRule;\n    readonly list: DefaultInOutRule;\n    readonly def: LenientInOutRule;\n    readonly table: DefaultInOutRule;\n    readonly tableSeparator: DefaultInRule;\n    readonly newline: TextInOutRule;\n    readonly paragraph: DefaultInOutRule;\n    readonly escape: DefaultInRule;\n    readonly autolink: DefaultInRule;\n    readonly mailto: DefaultInRule;\n    readonly url: DefaultInRule;\n    readonly link: DefaultInOutRule;\n    readonly image: DefaultInOutRule;\n    readonly reflink: DefaultInRule;\n    readonly refimage: DefaultInRule;\n    readonly em: DefaultInOutRule;\n    readonly strong: DefaultInOutRule;\n    readonly u: DefaultInOutRule;\n    readonly del: DefaultInOutRule;\n    readonly inlineCode: DefaultInOutRule;\n    readonly br: DefaultInOutRule;\n    readonly text: TextInOutRule;\n};\n\ntype RefNode = {\n    type: string;\n    content?: ASTNode;\n    target?: string;\n    title?: string;\n    alt?: string;\n};\n\n// End TypeScript Definitions\n\nvar CR_NEWLINE_R = /\\r\\n?/g;\nvar TAB_R = /\\t/g;\nvar FORMFEED_R = /\\f/g;\n\n/**\n * Turn various whitespace into easy-to-process whitespace\n */\nvar preprocess = function (source: string): string {\n    return source\n        .replace(CR_NEWLINE_R, \"\\n\")\n        .replace(FORMFEED_R, \"\")\n        .replace(TAB_R, \"    \");\n};\n\nvar populateInitialState = function (\n    givenState?: State | null,\n    defaultState?: State | null,\n): State {\n    var state: State = givenState || {};\n    if (defaultState != null) {\n        for (var prop in defaultState) {\n            if (Object.prototype.hasOwnProperty.call(defaultState, prop)) {\n                state[prop] = defaultState[prop];\n            }\n        }\n    }\n    return state;\n};\n\n/**\n * Creates a parser for a given set of rules, with the precedence\n * specified as a list of rules.\n *\n * @param {SimpleMarkdown.ParserRules} rules\n *     an object containing\n *     rule type -> {match, order, parse} objects\n *     (lower order is higher precedence)\n * @param {SimpleMarkdown.OptionalState} [defaultState]\n *\n * @returns {SimpleMarkdown.Parser}\n *     The resulting parse function, with the following parameters:\n *     @source: the input source string to be parsed\n *     @state: an optional object to be threaded through parse\n *         calls. Allows clients to add stateful operations to\n *         parsing, such as keeping track of how many levels deep\n *         some nesting is. For an example use-case, see passage-ref\n *         parsing in src/widgets/passage/passage-markdown.jsx\n */\nvar parserFor = function (\n    rules: ParserRules,\n    defaultState?: State | null,\n): Parser {\n    // Sorts rules in order of increasing order, then\n    // ascending rule name in case of ties.\n    var ruleList = Object.keys(rules).filter(function (type) {\n        var rule = rules[type];\n        if (rule == null || rule.match == null) {\n            return false;\n        }\n        var order = rule.order;\n        if (\n            (typeof order !== \"number\" || !isFinite(order)) &&\n            typeof console !== \"undefined\"\n        ) {\n            console.warn(\n                \"simple-markdown: Invalid order for rule `\" +\n                    type +\n                    \"`: \" +\n                    String(order),\n            );\n        }\n        return true;\n    });\n\n    ruleList.sort(function (typeA, typeB) {\n        var ruleA: ParserRule = rules[typeA] as any;\n        var ruleB: ParserRule = rules[typeB] as any;\n        var orderA = ruleA.order;\n        var orderB = ruleB.order;\n\n        // First sort based on increasing order\n        if (orderA !== orderB) {\n            return orderA - orderB;\n        }\n\n        var secondaryOrderA = ruleA.quality ? 0 : 1;\n        var secondaryOrderB = ruleB.quality ? 0 : 1;\n\n        if (secondaryOrderA !== secondaryOrderB) {\n            return secondaryOrderA - secondaryOrderB;\n\n            // Then based on increasing unicode lexicographic ordering\n        } else if (typeA < typeB) {\n            return -1;\n        } else if (typeA > typeB) {\n            return 1;\n        } else {\n            // Rules should never have the same name,\n            // but this is provided for completeness.\n            return 0;\n        }\n    });\n\n    var latestState: State;\n    var nestedParse: Parser = function (\n        source: string,\n        state?: State | null,\n    ): Array<SingleASTNode> {\n        var result: Array<SingleASTNode> = [];\n        state = state || latestState;\n        latestState = state;\n        while (source) {\n            // store the best match, it's rule, and quality:\n            var ruleType = null;\n            var rule = null;\n            var capture = null;\n            var quality = NaN;\n\n            // loop control variables:\n            var i = 0;\n            var currRuleType = ruleList[0];\n\n            var currRule: ParserRule = rules[currRuleType];\n\n            do {\n                var currOrder = currRule.order;\n                var prevCaptureStr =\n                    state.prevCapture == null ? \"\" : state.prevCapture[0];\n                var currCapture = currRule.match(source, state, prevCaptureStr);\n\n                if (currCapture) {\n                    var currQuality = currRule.quality\n                        ? currRule.quality(currCapture, state, prevCaptureStr)\n                        : 0;\n                    // This should always be true the first time because\n                    // the initial quality is NaN (that's why there's the\n                    // condition negation).\n                    if (!(currQuality <= quality)) {\n                        // @ts-expect-error - TS2322 - Type 'string' is not assignable to type 'null'.\n                        ruleType = currRuleType;\n                        // @ts-expect-error - TS2322 - Type 'ParserRule' is not assignable to type 'null'.\n                        rule = currRule;\n                        // @ts-expect-error - TS2322 - Type 'Capture' is not assignable to type 'null'.\n                        capture = currCapture;\n                        quality = currQuality;\n                    }\n                }\n\n                // Move on to the next item.\n                // Note that this makes `currRule` be the next item\n                i++;\n                currRuleType = ruleList[i];\n                currRule = rules[currRuleType];\n            } while (\n                // keep looping while we're still within the ruleList\n                currRule &&\n                // if we don't have a match yet, continue\n                (!capture ||\n                    // or if we have a match, but the next rule is\n                    // at the same order, and has a quality measurement\n                    // functions, then this rule must have a quality\n                    // measurement function (since they are sorted before\n                    // those without), and we need to check if there is\n                    // a better quality match\n                    (currRule.order === currOrder && currRule.quality))\n            );\n\n            // TODO(aria): Write tests for these\n            if (rule == null || capture == null) {\n                throw new Error(\n                    \"Could not find a matching rule for the below \" +\n                        \"content. The rule with highest `order` should \" +\n                        \"always match content provided to it. Check \" +\n                        \"the definition of `match` for '\" +\n                        ruleList[ruleList.length - 1] +\n                        \"'. It seems to not match the following source:\\n\" +\n                        source,\n                );\n            }\n            // @ts-expect-error - TS2339 - Property 'index' does not exist on type 'never'.\n            if (capture.index) {\n                // If present and non-zero, i.e. a non-^ regexp result:\n                throw new Error(\n                    \"`match` must return a capture starting at index 0 \" +\n                        \"(the current parse index). Did you forget a ^ at the \" +\n                        \"start of the RegExp?\",\n                );\n            }\n\n            // @ts-expect-error - TS2339 - Property 'parse' does not exist on type 'never'.\n            var parsed = rule.parse(capture, nestedParse, state);\n            // We maintain the same object here so that rules can\n            // store references to the objects they return and\n            // modify them later. (oops sorry! but this adds a lot\n            // of power--see reflinks.)\n            if (Array.isArray(parsed)) {\n                Array.prototype.push.apply(result, parsed);\n            } else {\n                if (parsed == null || typeof parsed !== \"object\") {\n                    throw new Error(\n                        `parse() function returned invalid parse result: '${parsed}'`,\n                    );\n                }\n\n                // We also let rules override the default type of\n                // their parsed node if they would like to, so that\n                // there can be a single output function for all links,\n                // even if there are several rules to parse them.\n                if (parsed.type == null) {\n                    parsed.type = ruleType;\n                }\n                result.push(parsed);\n            }\n\n            state.prevCapture = capture;\n            source = source.substring(state.prevCapture[0].length);\n        }\n\n        return result;\n    };\n\n    var outerParse: Parser = function (\n        source: string,\n        state?: State | null,\n    ): Array<SingleASTNode> {\n        latestState = populateInitialState(state, defaultState);\n        if (!latestState.inline && !latestState.disableAutoBlockNewlines) {\n            source = source + \"\\n\\n\";\n        }\n        // We store the previous capture so that match functions can\n        // use some limited amount of lookbehind. Lists use this to\n        // ensure they don't match arbitrary '- ' or '* ' in inline\n        // text (see the list rule for more information). This stores\n        // the full regex capture object, if there is one.\n        latestState.prevCapture = null;\n        return nestedParse(preprocess(source), latestState);\n    };\n\n    return outerParse;\n};\n\n// Creates a match function for an inline scoped element from a regex\nvar inlineRegex = function (regex: RegExp): MatchFunction {\n    var match = function (\n        source: string,\n        state: State,\n        prevCapture: string,\n    ): Capture | null | undefined {\n        if (state.inline) {\n            return regex.exec(source);\n        } else {\n            return null;\n        }\n    };\n    // @ts-expect-error - TS2339 - Property 'regex' does not exist on type '(source: string, state: State, prevCapture: string) => Capture | null | undefined'.\n    match.regex = regex;\n\n    return match;\n};\n\n// Creates a match function for a block scoped element from a regex\nvar blockRegex = function (regex: RegExp): MatchFunction {\n    var match: MatchFunction = function (source, state) {\n        if (state.inline) {\n            return null;\n        } else {\n            return regex.exec(source);\n        }\n    };\n    match.regex = regex;\n    return match;\n};\n\n// Creates a match function from a regex, ignoring block/inline scope\nvar anyScopeRegex = function (regex: RegExp): MatchFunction {\n    var match: MatchFunction = function (source, state) {\n        return regex.exec(source);\n    };\n    match.regex = regex;\n    return match;\n};\n\nvar TYPE_SYMBOL =\n    (typeof Symbol === \"function\" &&\n        Symbol.for &&\n        Symbol.for(\"react.element\")) ||\n    0xeac7;\n\nvar reactElement = function (\n    type: string,\n    key: string | number | null | undefined,\n    props: {\n        [key: string]: any;\n    },\n): ReactElement {\n    var element: ReactElement = {\n        $$typeof: TYPE_SYMBOL,\n        type: type,\n        key: key == null ? undefined : key,\n        ref: null,\n        props: props,\n        _owner: null,\n    } as any;\n    return element;\n};\n\n/** Returns a closed HTML tag.\n * @param {string} tagName - Name of HTML tag (eg. \"em\" or \"a\")\n * @param {string} content - Inner content of tag\n * @param {{ [attr: string]: SimpleMarkdown.Attr }} [attributes] - Optional extra attributes of tag as an object of key-value pairs\n *   eg. { \"href\": \"http://google.com\" }. Falsey attributes are filtered out.\n * @param {boolean} [isClosed] - boolean that controls whether tag is closed or not (eg. img tags).\n *   defaults to true\n */\nvar htmlTag = function (\n    tagName: string,\n    content: string,\n    attributes?: Partial<Record<any, Attr | null | undefined>> | null,\n    isClosed?: boolean | null,\n) {\n    attributes = attributes || {};\n    isClosed = typeof isClosed !== \"undefined\" ? isClosed : true;\n\n    var attributeString = \"\";\n    for (var attr in attributes) {\n        var attribute = attributes[attr];\n        // Removes falsey attributes\n        if (\n            Object.prototype.hasOwnProperty.call(attributes, attr) &&\n            attribute\n        ) {\n            attributeString +=\n                \" \" + sanitizeText(attr) + '=\"' + sanitizeText(attribute) + '\"';\n        }\n    }\n\n    var unclosedTag = \"<\" + tagName + attributeString + \">\";\n\n    if (isClosed) {\n        return unclosedTag + content + \"</\" + tagName + \">\";\n    } else {\n        return unclosedTag;\n    }\n};\n\nvar EMPTY_PROPS: Record<string, any> = {};\n\n/**\n * @param {string | null | undefined} url - url to sanitize\n * @returns {string | null} - url if safe, or null if a safe url could not be made\n */\nvar sanitizeUrl = function (url?: string | null) {\n    if (url == null) {\n        return null;\n    }\n    try {\n        var prot = new URL(url, \"https://localhost\").protocol;\n        if (\n            prot.indexOf(\"javascript:\") === 0 ||\n            prot.indexOf(\"vbscript:\") === 0 ||\n            prot.indexOf(\"data:\") === 0\n        ) {\n            return null;\n        }\n    } catch {\n        // invalid URLs should throw a TypeError\n        // see for instance: `new URL(\"\");`\n        return null;\n    }\n    return url;\n};\n\nvar SANITIZE_TEXT_R = /[<>&\"']/g;\nvar SANITIZE_TEXT_CODES = {\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    \"&\": \"&amp;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#x27;\",\n    \"/\": \"&#x2F;\",\n    \"`\": \"&#96;\",\n};\n\nvar sanitizeText = function (text: Attr): string {\n    return String(text).replace(SANITIZE_TEXT_R, function (chr) {\n        return SANITIZE_TEXT_CODES[chr];\n    });\n};\n\nvar UNESCAPE_URL_R = /\\\\([^0-9A-Za-z\\s])/g;\n\nvar unescapeUrl = function (rawUrlString: string): string {\n    return rawUrlString.replace(UNESCAPE_URL_R, \"$1\");\n};\n\n/**\n * Parse some content with the parser `parse`, with state.inline\n * set to true. Useful for block elements; not generally necessary\n * to be used by inline elements (where state.inline is already true.\n */\nvar parseInline = function (\n    parse: Parser,\n    content: string,\n    state: State,\n): ASTNode {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = true;\n    var result = parse(content, state);\n    state.inline = isCurrentlyInline;\n    return result;\n};\n\nvar parseBlock = function (\n    parse: Parser,\n    content: string,\n    state: State,\n): ASTNode {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = false;\n    var result = parse(content + \"\\n\\n\", state);\n    state.inline = isCurrentlyInline;\n    return result;\n};\n\nvar parseCaptureInline = function (\n    capture: Capture,\n    parse: Parser,\n    state: State,\n): UnTypedASTNode {\n    return {\n        content: parseInline(parse, capture[1], state),\n    };\n};\n\nvar ignoreCapture = function (): UnTypedASTNode {\n    return {};\n};\n\n// recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\nvar LIST_BULLET = \"(?:[*+-]|\\\\d+\\\\.)\";\n// recognize the start of a list item:\n// leading space plus a bullet plus a space (`   * `)\nvar LIST_ITEM_PREFIX = \"( *)(\" + LIST_BULLET + \") +\";\nvar LIST_ITEM_PREFIX_R = new RegExp(\"^\" + LIST_ITEM_PREFIX);\n// recognize an individual list item:\n//  * hi\n//    this is part of the same item\n//\n//    as is this, which is a new paragraph in the same item\n//\n//  * but this is not part of the same item\nvar LIST_ITEM_R = new RegExp(\n    LIST_ITEM_PREFIX +\n        \"[^\\\\n]*(?:\\\\n\" +\n        \"(?!\\\\1\" +\n        LIST_BULLET +\n        \" )[^\\\\n]*)*(\\n|$)\",\n    \"gm\",\n);\nvar BLOCK_END_R = /\\n{2,}$/;\nvar INLINE_CODE_ESCAPE_BACKTICKS_R = /^ (?= *`)|(` *) $/g;\n// recognize the end of a paragraph block inside a list item:\n// two or more newlines at end end of the item\nvar LIST_BLOCK_END_R = BLOCK_END_R;\nvar LIST_ITEM_END_R = / *\\n+$/;\n// check whether a list item has paragraphs: if it does,\n// we leave the newlines at the end\nvar LIST_R = new RegExp(\n    \"^( *)(\" +\n        LIST_BULLET +\n        \") \" +\n        \"[\\\\s\\\\S]+?(?:\\n{2,}(?! )\" +\n        \"(?!\\\\1\" +\n        LIST_BULLET +\n        \" )\\\\n*\" +\n        // the \\\\s*$ here is so that we can parse the inside of nested\n        // lists, where our content might end before we receive two `\\n`s\n        \"|\\\\s*\\n*$)\",\n);\nvar LIST_LOOKBEHIND_R = /(?:^|\\n)( *)$/;\n\nvar TABLES = (function () {\n    // predefine regexes so we don't have to create them inside functions\n    // sure, regex literals should be fast, even inside functions, but they\n    // aren't in all browsers.\n    var TABLE_ROW_SEPARATOR_TRIM = /^ *\\| *| *\\| *$/g;\n    var TABLE_CELL_END_TRIM = / *$/;\n    var TABLE_RIGHT_ALIGN = /^ *-+: *$/;\n    var TABLE_CENTER_ALIGN = /^ *:-+: *$/;\n    var TABLE_LEFT_ALIGN = /^ *:-+ *$/;\n\n    // TODO: This needs a real type\n    type TableAlignment = any;\n\n    var parseTableAlignCapture = function (\n        alignCapture: string,\n    ): TableAlignment {\n        if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n            return \"right\";\n        } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n            return \"center\";\n        } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n            return \"left\";\n        } else {\n            return null;\n        }\n    };\n\n    var parseTableAlign = function (\n        source: string,\n        parse: Parser,\n        state: State,\n        trimEndSeparators: boolean,\n    ): Array<TableAlignment> {\n        if (trimEndSeparators) {\n            source = source.replace(TABLE_ROW_SEPARATOR_TRIM, \"\");\n        }\n        var alignText = source.trim().split(\"|\");\n        return alignText.map(parseTableAlignCapture);\n    };\n\n    var parseTableRow = function (\n        source: string,\n        parse: Parser,\n        state: State,\n        trimEndSeparators: boolean,\n    ): Array<Array<SingleASTNode>> {\n        var prevInTable = state.inTable;\n        state.inTable = true;\n        var tableRow = parse(source.trim(), state);\n        state.inTable = prevInTable;\n\n        var cells = [[]];\n        tableRow.forEach(function (node, i) {\n            if (node.type === \"tableSeparator\") {\n                // Filter out empty table separators at the start/end:\n                if (\n                    !trimEndSeparators ||\n                    (i !== 0 && i !== tableRow.length - 1)\n                ) {\n                    // Split the current row:\n                    cells.push([]);\n                }\n            } else {\n                if (\n                    node.type === \"text\" &&\n                    (tableRow[i + 1] == null ||\n                        tableRow[i + 1].type === \"tableSeparator\")\n                ) {\n                    node.content = node.content.replace(\n                        TABLE_CELL_END_TRIM,\n                        \"\",\n                    );\n                }\n                // @ts-expect-error - TS2345 - Argument of type 'SingleASTNode' is not assignable to parameter of type 'never'.\n                cells[cells.length - 1].push(node);\n            }\n        });\n\n        return cells;\n    };\n\n    /**\n     * @param {string} source\n     * @param {SimpleMarkdown.Parser} parse\n     * @param {SimpleMarkdown.State} state\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.ASTNode[][]}\n     */\n    var parseTableCells = function (\n        source: string,\n        parse: Parser,\n        state: State,\n        trimEndSeparators: boolean,\n    ): Array<Array<ASTNode>> {\n        var rowsText = source.trim().split(\"\\n\");\n\n        return rowsText.map(function (rowText) {\n            return parseTableRow(rowText, parse, state, trimEndSeparators);\n        });\n    };\n\n    /**\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.SingleNodeParseFunction}\n     */\n    var parseTable = function (trimEndSeparators: boolean) {\n        return function (capture: Capture, parse: Parser, state: State) {\n            state.inline = true;\n            var header = parseTableRow(\n                capture[1],\n                parse,\n                state,\n                trimEndSeparators,\n            );\n            var align = parseTableAlign(\n                capture[2],\n                parse,\n                state,\n                trimEndSeparators,\n            );\n            var cells = parseTableCells(\n                capture[3],\n                parse,\n                state,\n                trimEndSeparators,\n            );\n            state.inline = false;\n\n            return {\n                type: \"table\",\n                header: header,\n                align: align,\n                cells: cells,\n            };\n        };\n    };\n\n    return {\n        parseTable: parseTable(true),\n        parseNpTable: parseTable(false),\n        TABLE_REGEX:\n            /^ *(\\|.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/,\n        NPTABLE_REGEX:\n            /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/,\n    };\n})();\n\nvar LINK_INSIDE = \"(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*\";\nvar LINK_HREF_AND_TITLE =\n    \"\\\\s*<?((?:\\\\([^)]*\\\\)|[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+['\\\"]([\\\\s\\\\S]*?)['\\\"])?\\\\s*\";\nvar AUTOLINK_MAILTO_CHECK_R = /mailto:/i;\n\nvar parseRef = function (\n    capture: Capture,\n    state: State,\n    refNode: RefNode,\n): RefNode {\n    var ref = (capture[2] || capture[1]).replace(/\\s+/g, \" \").toLowerCase();\n\n    // We store information about previously seen defs on\n    // state._defs (_ to deconflict with client-defined\n    // state). If the def for this reflink/refimage has\n    // already been seen, we can use its target/source\n    // and title here:\n    if (state._defs && state._defs[ref]) {\n        var def = state._defs[ref];\n        // `refNode` can be a link or an image. Both use\n        // target and title properties.\n        refNode.target = def.target;\n        refNode.title = def.title;\n    }\n\n    // In case we haven't seen our def yet (or if someone\n    // overwrites that def later on), we add this node\n    // to the list of ref nodes for that def. Then, when\n    // we find the def, we can modify this link/image AST\n    // node :).\n    // I'm sorry.\n    state._refs = state._refs || {};\n    state._refs[ref] = state._refs[ref] || [];\n    state._refs[ref].push(refNode);\n\n    return refNode;\n};\n\nvar currOrder = 0;\n\nvar defaultRules: DefaultRules = {\n    Array: {\n        react: function (arr, output, state) {\n            var oldKey = state.key;\n            var result: Array<ReactElements> = [];\n\n            // map output over the ast, except group any text\n            // nodes together into a single string output.\n            for (var i = 0, key = 0; i < arr.length; i++, key++) {\n                // `key` is our numerical `state.key`, which we increment for\n                // every output node, but don't change for joined text nodes.\n                // (i, however, must change for joined text nodes)\n                state.key = \"\" + i;\n\n                var node = arr[i];\n                if (node.type === \"text\") {\n                    node = {type: \"text\", content: node.content};\n                    for (\n                        ;\n                        i + 1 < arr.length && arr[i + 1].type === \"text\";\n                        i++\n                    ) {\n                        node.content += arr[i + 1].content;\n                    }\n                }\n\n                result.push(output(node, state));\n            }\n\n            state.key = oldKey;\n            return result;\n        },\n        html: function (arr, output, state) {\n            var result = \"\";\n\n            // map output over the ast, except group any text\n            // nodes together into a single string output.\n            for (var i = 0; i < arr.length; i++) {\n                var node = arr[i];\n                if (node.type === \"text\") {\n                    node = {type: \"text\", content: node.content};\n                    for (\n                        ;\n                        i + 1 < arr.length && arr[i + 1].type === \"text\";\n                        i++\n                    ) {\n                        node.content += arr[i + 1].content;\n                    }\n                }\n\n                result += output(node, state);\n            }\n            return result;\n        },\n    },\n    heading: {\n        order: currOrder++,\n        match: blockRegex(/^ *(#{1,6})([^\\n]+?)#* *(?:\\n *)+\\n/),\n        parse: function (capture, parse, state) {\n            return {\n                level: capture[1].length,\n                content: parseInline(parse, capture[2].trim(), state),\n            };\n        },\n        react: function (node, output, state) {\n            return reactElement(\"h\" + node.level, state.key, {\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            return htmlTag(\"h\" + node.level, output(node.content, state));\n        },\n    },\n    nptable: {\n        order: currOrder++,\n        match: blockRegex(TABLES.NPTABLE_REGEX),\n        parse: TABLES.parseNpTable,\n        react: null,\n        html: null,\n    },\n    lheading: {\n        order: currOrder++,\n        match: blockRegex(/^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/),\n        parse: function (capture, parse, state) {\n            return {\n                type: \"heading\",\n                level: capture[2] === \"=\" ? 1 : 2,\n                content: parseInline(parse, capture[1], state),\n            };\n        },\n        react: null,\n        html: null,\n    },\n    hr: {\n        order: currOrder++,\n        match: blockRegex(/^( *[-*_]){3,} *(?:\\n *)+\\n/),\n        parse: ignoreCapture,\n        react: function (node, output, state) {\n            return reactElement(\"hr\", state.key, {\"aria-hidden\": true});\n        },\n        html: function (node, output, state) {\n            return '<hr aria-hidden=\"true\">';\n        },\n    },\n    codeBlock: {\n        order: currOrder++,\n        match: blockRegex(/^(?:    [^\\n]+\\n*)+(?:\\n *)+\\n/),\n        parse: function (capture, parse, state) {\n            var content = capture[0].replace(/^    /gm, \"\").replace(/\\n+$/, \"\");\n            return {\n                lang: undefined,\n                content: content,\n            };\n        },\n        react: function (node, output, state) {\n            var className = node.lang\n                ? \"markdown-code-\" + node.lang\n                : undefined;\n\n            return reactElement(\"pre\", state.key, {\n                children: reactElement(\"code\", null, {\n                    className: className,\n                    children: node.content,\n                }),\n            });\n        },\n        html: function (node, output, state) {\n            var className = node.lang\n                ? \"markdown-code-\" + node.lang\n                : undefined;\n\n            var codeBlock = htmlTag(\"code\", sanitizeText(node.content), {\n                class: className,\n            });\n            return htmlTag(\"pre\", codeBlock);\n        },\n    },\n    fence: {\n        order: currOrder++,\n        match: blockRegex(\n            /^ *(`{3,}|~{3,}) *(?:(\\S+) *)?\\n([\\s\\S]+?)\\n?\\1 *(?:\\n *)+\\n/,\n        ),\n        parse: function (capture, parse, state) {\n            return {\n                type: \"codeBlock\",\n                lang: capture[2] || undefined,\n                content: capture[3],\n            };\n        },\n        react: null,\n        html: null,\n    },\n    blockQuote: {\n        order: currOrder++,\n        match: blockRegex(/^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/),\n        parse: function (capture, parse, state) {\n            var content = capture[0].replace(/^ *> ?/gm, \"\");\n            return {\n                content: parse(content, state),\n            };\n        },\n        react: function (node, output, state) {\n            return reactElement(\"blockquote\", state.key, {\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            return htmlTag(\"blockquote\", output(node.content, state));\n        },\n    },\n    list: {\n        order: currOrder++,\n        match: function (source, state) {\n            // We only want to break into a list if we are at the start of a\n            // line. This is to avoid parsing \"hi * there\" with \"* there\"\n            // becoming a part of a list.\n            // You might wonder, \"but that's inline, so of course it wouldn't\n            // start a list?\". You would be correct! Except that some of our\n            // lists can be inline, because they might be inside another list,\n            // in which case we can parse with inline scope, but need to allow\n            // nested lists inside this inline scope.\n            var prevCaptureStr =\n                state.prevCapture == null ? \"\" : state.prevCapture[0];\n            var isStartOfLineCapture = LIST_LOOKBEHIND_R.exec(prevCaptureStr);\n            var isListBlock = state._list || !state.inline;\n\n            if (isStartOfLineCapture && isListBlock) {\n                source = isStartOfLineCapture[1] + source;\n                return LIST_R.exec(source);\n            } else {\n                return null;\n            }\n        },\n        parse: function (capture, parse, state) {\n            var bullet = capture[2];\n            var ordered = bullet.length > 1;\n            var start = ordered ? +bullet : undefined;\n            // @ts-expect-error - TS2322 - Type 'RegExpMatchArray | null' is not assignable to type 'string[]'.\n            var items: Array<string> = capture[0]\n                .replace(LIST_BLOCK_END_R, \"\\n\")\n                .match(LIST_ITEM_R);\n\n            // We know this will match here, because of how the regexes are\n            // defined\n\n            var lastItemWasAParagraph = false;\n            var itemContent = items.map(function (item: string, i: number) {\n                // We need to see how far indented this item is:\n                var prefixCapture = LIST_ITEM_PREFIX_R.exec(item);\n                var space = prefixCapture ? prefixCapture[0].length : 0;\n                // And then we construct a regex to \"unindent\" the subsequent\n                // lines of the items by that amount:\n                var spaceRegex = new RegExp(\"^ {1,\" + space + \"}\", \"gm\");\n\n                // Before processing the item, we need a couple things\n                var content = item\n                    // remove indents on trailing lines:\n                    .replace(spaceRegex, \"\")\n                    // remove the bullet:\n                    .replace(LIST_ITEM_PREFIX_R, \"\");\n\n                // I'm not sur4 why this is necessary again?\n\n                // Handling \"loose\" lists, like:\n                //\n                //  * this is wrapped in a paragraph\n                //\n                //  * as is this\n                //\n                //  * as is this\n                var isLastItem = i === items.length - 1;\n                var containsBlocks = content.indexOf(\"\\n\\n\") !== -1;\n\n                // Any element in a list is a block if it contains multiple\n                // newlines. The last element in the list can also be a block\n                // if the previous item in the list was a block (this is\n                // because non-last items in the list can end with \\n\\n, but\n                // the last item can't, so we just \"inherit\" this property\n                // from our previous element).\n                var thisItemIsAParagraph =\n                    containsBlocks || (isLastItem && lastItemWasAParagraph);\n                lastItemWasAParagraph = thisItemIsAParagraph;\n\n                // backup our state for restoration afterwards. We're going to\n                // want to set state._list to true, and state.inline depending\n                // on our list's looseness.\n                var oldStateInline = state.inline;\n                var oldStateList = state._list;\n                state._list = true;\n\n                // Parse inline if we're in a tight list, or block if we're in\n                // a loose list.\n                var adjustedContent;\n                if (thisItemIsAParagraph) {\n                    state.inline = false;\n                    adjustedContent = content.replace(LIST_ITEM_END_R, \"\\n\\n\");\n                } else {\n                    state.inline = true;\n                    adjustedContent = content.replace(LIST_ITEM_END_R, \"\");\n                }\n\n                var result = parse(adjustedContent, state);\n\n                // Restore our state before returning\n                state.inline = oldStateInline;\n                state._list = oldStateList;\n                return result;\n            });\n\n            return {\n                ordered: ordered,\n                start: start,\n                items: itemContent,\n            };\n        },\n        react: function (node, output, state) {\n            var ListWrapper = node.ordered ? \"ol\" : \"ul\";\n\n            return reactElement(ListWrapper, state.key, {\n                start: node.start,\n                children: node.items.map(function (item: ASTNode, i: number) {\n                    return reactElement(\"li\", \"\" + i, {\n                        children: output(item, state),\n                    });\n                }),\n            });\n        },\n        html: function (node, output, state) {\n            var listItems = node.items\n                .map(function (item: ASTNode) {\n                    return htmlTag(\"li\", output(item, state));\n                })\n                .join(\"\");\n\n            var listTag = node.ordered ? \"ol\" : \"ul\";\n            var attributes = {\n                start: node.start,\n            };\n            return htmlTag(listTag, listItems, attributes);\n        },\n    },\n    def: {\n        order: currOrder++,\n        // TODO(aria): This will match without a blank line before the next\n        // block element, which is inconsistent with most of the rest of\n        // simple-markdown.\n        match: blockRegex(\n            /^ *\\[([^\\]]+)\\]: *<?([^\\s>]*)>?(?: +[\"(]([^\\n]+)[\")])? *\\n(?: *\\n)*/,\n        ),\n        parse: function (capture, parse, state) {\n            var def = capture[1].replace(/\\s+/g, \" \").toLowerCase();\n            var target = capture[2];\n            var title = capture[3];\n\n            // Look for previous links/images using this def\n            // If any links/images using this def have already been declared,\n            // they will have added themselves to the state._refs[def] list\n            // (_ to deconflict with client-defined state). We look through\n            // that list of reflinks for this def, and modify those AST nodes\n            // with our newly found information now.\n            // Sorry :(.\n            if (state._refs && state._refs[def]) {\n                // `refNode` can be a link or an image\n                state._refs[def].forEach(function (refNode: RefNode) {\n                    refNode.target = target;\n                    refNode.title = title;\n                });\n            }\n\n            // Add this def to our map of defs for any future links/images\n            // In case we haven't found any or all of the refs referring to\n            // this def yet, we add our def to the table of known defs, so\n            // that future reflinks can modify themselves appropriately with\n            // this information.\n            state._defs = state._defs || {};\n            state._defs[def] = {\n                target: target,\n                title: title,\n            };\n\n            // return the relevant parsed information\n            // for debugging only.\n            return {\n                def: def,\n                target: target,\n                title: title,\n            };\n        },\n        react: function () {\n            return null;\n        },\n        html: function () {\n            return \"\";\n        },\n    },\n    table: {\n        order: currOrder++,\n        match: blockRegex(TABLES.TABLE_REGEX),\n        parse: TABLES.parseTable,\n        react: function (node, output, state) {\n            var getStyle = function (colIndex: number): {\n                [attr: string]: Attr;\n            } {\n                return node.align[colIndex] == null\n                    ? {}\n                    : {\n                          textAlign: node.align[colIndex],\n                      };\n            };\n\n            var headers = node.header.map(function (\n                content: ASTNode,\n                i: number,\n            ) {\n                return reactElement(\"th\", \"\" + i, {\n                    style: getStyle(i),\n                    scope: \"col\",\n                    children: output(content, state),\n                });\n            });\n\n            var rows = node.cells.map(function (\n                row: Array<ASTNode>,\n                r: number,\n            ) {\n                return reactElement(\"tr\", \"\" + r, {\n                    children: row.map(function (content: ASTNode, c: number) {\n                        return reactElement(\"td\", \"\" + c, {\n                            style: getStyle(c),\n                            children: output(content, state),\n                        });\n                    }),\n                });\n            });\n\n            return reactElement(\"table\", state.key, {\n                children: [\n                    reactElement(\"thead\", \"thead\", {\n                        children: reactElement(\"tr\", null, {\n                            children: headers,\n                        }),\n                    }),\n                    reactElement(\"tbody\", \"tbody\", {\n                        children: rows,\n                    }),\n                ],\n            });\n        },\n        html: function (node, output, state) {\n            var getStyle = function (colIndex: number): string {\n                return node.align[colIndex] == null\n                    ? \"\"\n                    : \"text-align:\" + node.align[colIndex] + \";\";\n            };\n\n            var headers = node.header\n                .map(function (content: ASTNode, i: number) {\n                    return htmlTag(\"th\", output(content, state), {\n                        style: getStyle(i),\n                        scope: \"col\",\n                    });\n                })\n                .join(\"\");\n\n            var rows = node.cells\n                .map(function (row: Array<ASTNode>) {\n                    var cols = row\n                        .map(function (content: ASTNode, c: number) {\n                            return htmlTag(\"td\", output(content, state), {\n                                style: getStyle(c),\n                            });\n                        })\n                        .join(\"\");\n\n                    return htmlTag(\"tr\", cols);\n                })\n                .join(\"\");\n\n            var thead = htmlTag(\"thead\", htmlTag(\"tr\", headers));\n            var tbody = htmlTag(\"tbody\", rows);\n\n            return htmlTag(\"table\", thead + tbody);\n        },\n    },\n    newline: {\n        order: currOrder++,\n        match: blockRegex(/^(?:\\n *)*\\n/),\n        parse: ignoreCapture,\n        react: function (node, output, state) {\n            return \"\\n\";\n        },\n        html: function (node, output, state) {\n            return \"\\n\";\n        },\n    },\n    paragraph: {\n        order: currOrder++,\n        match: blockRegex(/^((?:[^\\n]|\\n(?! *\\n))+)(?:\\n *)+\\n/),\n        parse: parseCaptureInline,\n        react: function (node, output, state) {\n            return reactElement(\"div\", state.key, {\n                className: \"paragraph\",\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            var attributes = {\n                class: \"paragraph\",\n            };\n            return htmlTag(\"div\", output(node.content, state), attributes);\n        },\n    },\n    escape: {\n        order: currOrder++,\n        // We don't allow escaping numbers, letters, or spaces here so that\n        // backslashes used in plain text still get rendered. But allowing\n        // escaping anything else provides a very flexible escape mechanism,\n        // regardless of how this grammar is extended.\n        match: inlineRegex(/^\\\\([^0-9A-Za-z\\s])/),\n        parse: function (capture, parse, state) {\n            return {\n                type: \"text\",\n                content: capture[1],\n            };\n        },\n        react: null,\n        html: null,\n    },\n    tableSeparator: {\n        order: currOrder++,\n        match: function (source, state) {\n            if (!state.inTable) {\n                return null;\n            }\n            return /^ *\\| */.exec(source);\n        },\n        parse: function () {\n            return {type: \"tableSeparator\"};\n        },\n        // These shouldn't be reached, but in case they are, be reasonable:\n        react: function () {\n            return \" | \";\n        },\n        html: function () {\n            return \" &vert; \";\n        },\n    },\n    autolink: {\n        order: currOrder++,\n        match: inlineRegex(/^<([^: >]+:\\/[^ >]+)>/),\n        parse: function (capture, parse, state) {\n            return {\n                type: \"link\",\n                content: [\n                    {\n                        type: \"text\",\n                        content: capture[1],\n                    },\n                ],\n                target: capture[1],\n            };\n        },\n        react: null,\n        html: null,\n    },\n    mailto: {\n        order: currOrder++,\n        match: inlineRegex(/^<([^ >]+@[^ >]+)>/),\n        parse: function (capture, parse, state) {\n            var address = capture[1];\n            var target = capture[1];\n\n            // Check for a `mailto:` already existing in the link:\n            if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n                target = \"mailto:\" + target;\n            }\n\n            return {\n                type: \"link\",\n                content: [\n                    {\n                        type: \"text\",\n                        content: address,\n                    },\n                ],\n                target: target,\n            };\n        },\n        react: null,\n        html: null,\n    },\n    url: {\n        order: currOrder++,\n        match: inlineRegex(/^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/),\n        parse: function (capture, parse, state) {\n            return {\n                type: \"link\",\n                content: [\n                    {\n                        type: \"text\",\n                        content: capture[1],\n                    },\n                ],\n                target: capture[1],\n                title: undefined,\n            };\n        },\n        react: null,\n        html: null,\n    },\n    link: {\n        order: currOrder++,\n        match: inlineRegex(\n            new RegExp(\n                \"^\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\",\n            ),\n        ),\n        parse: function (capture, parse, state) {\n            var link = {\n                content: parse(capture[1], state),\n                target: unescapeUrl(capture[2]),\n                title: capture[3],\n            };\n            return link;\n        },\n        react: function (node, output, state) {\n            return reactElement(\"a\", state.key, {\n                href: sanitizeUrl(node.target),\n                title: node.title,\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            var attributes = {\n                href: sanitizeUrl(node.target),\n                title: node.title,\n            };\n\n            return htmlTag(\"a\", output(node.content, state), attributes);\n        },\n    },\n    image: {\n        order: currOrder++,\n        match: inlineRegex(\n            new RegExp(\n                \"^!\\\\[(\" +\n                    LINK_INSIDE +\n                    \")\\\\]\\\\(\" +\n                    LINK_HREF_AND_TITLE +\n                    \"\\\\)\",\n            ),\n        ),\n        parse: function (capture, parse, state) {\n            var image = {\n                alt: capture[1],\n                target: unescapeUrl(capture[2]),\n                title: capture[3],\n            };\n            return image;\n        },\n        react: function (node, output, state) {\n            return reactElement(\"img\", state.key, {\n                src: sanitizeUrl(node.target),\n                alt: node.alt,\n                title: node.title,\n            });\n        },\n        html: function (node, output, state) {\n            var attributes = {\n                src: sanitizeUrl(node.target),\n                alt: node.alt,\n                title: node.title,\n            };\n\n            return htmlTag(\"img\", \"\", attributes, false);\n        },\n    },\n    reflink: {\n        order: currOrder++,\n        match: inlineRegex(\n            new RegExp(\n                // The first [part] of the link\n                \"^\\\\[(\" +\n                    LINK_INSIDE +\n                    \")\\\\]\" +\n                    // The [ref] target of the link\n                    \"\\\\s*\\\\[([^\\\\]]*)\\\\]\",\n            ),\n        ),\n        parse: function (capture, parse, state) {\n            return parseRef(capture, state, {\n                type: \"link\",\n                content: parse(capture[1], state),\n            });\n        },\n        react: null,\n        html: null,\n    },\n    refimage: {\n        order: currOrder++,\n        match: inlineRegex(\n            new RegExp(\n                // The first [part] of the link\n                \"^!\\\\[(\" +\n                    LINK_INSIDE +\n                    \")\\\\]\" +\n                    // The [ref] target of the link\n                    \"\\\\s*\\\\[([^\\\\]]*)\\\\]\",\n            ),\n        ),\n        parse: function (capture, parse, state) {\n            return parseRef(capture, state, {\n                type: \"image\",\n                alt: capture[1],\n            });\n        },\n        react: null,\n        html: null,\n    },\n    em: {\n        order: currOrder /* same as strong/u */,\n        match: inlineRegex(\n            new RegExp(\n                // only match _s surrounding words.\n                \"^\\\\b_\" +\n                    \"((?:__|\\\\\\\\[\\\\s\\\\S]|[^\\\\\\\\_])+?)_\" +\n                    \"\\\\b\" +\n                    // Or match *s:\n                    \"|\" +\n                    // Only match *s that are followed by a non-space:\n                    \"^\\\\*(?=\\\\S)(\" +\n                    // Match at least one of:\n                    \"(?:\" +\n                    //  - `**`: so that bolds inside italics don't close the\n                    //          italics\n                    \"\\\\*\\\\*|\" +\n                    //  - escape sequence: so escaped *s don't close us\n                    \"\\\\\\\\[\\\\s\\\\S]|\" +\n                    //  - whitespace: followed by a non-* (we don't\n                    //          want ' *' to close an italics--it might\n                    //          start a list)\n                    \"\\\\s+(?:\\\\\\\\[\\\\s\\\\S]|[^\\\\s\\\\*\\\\\\\\]|\\\\*\\\\*)|\" +\n                    //  - non-whitespace, non-*, non-backslash characters\n                    \"[^\\\\s\\\\*\\\\\\\\]\" +\n                    \")+?\" +\n                    // followed by a non-space, non-* then *\n                    \")\\\\*(?!\\\\*)\",\n            ),\n        ),\n        quality: function (capture) {\n            // precedence by length, `em` wins ties:\n            return capture[0].length + 0.2;\n        },\n        parse: function (capture, parse, state) {\n            return {\n                content: parse(capture[2] || capture[1], state),\n            };\n        },\n        react: function (node, output, state) {\n            return reactElement(\"em\", state.key, {\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            return htmlTag(\"em\", output(node.content, state));\n        },\n    },\n    strong: {\n        order: currOrder /* same as em */,\n        match: inlineRegex(/^\\*\\*((?:\\\\[\\s\\S]|[^\\\\])+?)\\*\\*(?!\\*)/),\n        quality: function (capture) {\n            // precedence by length, wins ties vs `u`:\n            return capture[0].length + 0.1;\n        },\n        parse: parseCaptureInline,\n        react: function (node, output, state) {\n            return reactElement(\"strong\", state.key, {\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            return htmlTag(\"strong\", output(node.content, state));\n        },\n    },\n    u: {\n        order: currOrder++ /* same as em&strong; increment for next rule */,\n        match: inlineRegex(/^__((?:\\\\[\\s\\S]|[^\\\\])+?)__(?!_)/),\n        quality: function (capture) {\n            // precedence by length, loses all ties\n            return capture[0].length;\n        },\n        parse: parseCaptureInline,\n        react: function (node, output, state) {\n            return reactElement(\"u\", state.key, {\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            return htmlTag(\"u\", output(node.content, state));\n        },\n    },\n    del: {\n        order: currOrder++,\n        match: inlineRegex(\n            /^~~(?=\\S)((?:\\\\[\\s\\S]|~(?!~)|[^\\s~\\\\]|\\s(?!~~))+?)~~/,\n        ),\n        parse: parseCaptureInline,\n        react: function (node, output, state) {\n            return reactElement(\"del\", state.key, {\n                children: output(node.content, state),\n            });\n        },\n        html: function (node, output, state) {\n            return htmlTag(\"del\", output(node.content, state));\n        },\n    },\n    inlineCode: {\n        order: currOrder++,\n        match: inlineRegex(/^(`+)([\\s\\S]*?[^`])\\1(?!`)/),\n        parse: function (capture, parse, state) {\n            return {\n                content: capture[2].replace(\n                    INLINE_CODE_ESCAPE_BACKTICKS_R,\n                    \"$1\",\n                ),\n            };\n        },\n        react: function (node, output, state) {\n            return reactElement(\"code\", state.key, {\n                children: node.content,\n            });\n        },\n        html: function (node, output, state) {\n            return htmlTag(\"code\", sanitizeText(node.content));\n        },\n    },\n    br: {\n        order: currOrder++,\n        match: anyScopeRegex(/^ {2,}\\n/),\n        parse: ignoreCapture,\n        react: function (node, output, state) {\n            return reactElement(\"br\", state.key, EMPTY_PROPS);\n        },\n        html: function (node, output, state) {\n            return \"<br>\";\n        },\n    },\n    text: {\n        order: currOrder++,\n        // Here we look for anything followed by non-symbols,\n        // double newlines, or double-space-newlines\n        // We break on any symbol characters so that this grammar\n        // is easy to extend without needing to modify this regex\n        match: anyScopeRegex(\n            /^[\\s\\S]+?(?=[^0-9A-Za-z\\s\\u00c0-\\uffff]|\\n\\n| {2,}\\n|\\w+:\\S|$)/,\n        ),\n        parse: function (capture, parse, state) {\n            return {\n                content: capture[0],\n            };\n        },\n        react: function (node, output, state) {\n            return node.content;\n        },\n        html: function (node, output, state) {\n            return sanitizeText(node.content);\n        },\n    },\n};\n\n/** (deprecated) */\nvar ruleOutput = function <Rule>(\n    rules: OutputRules<Rule>,\n    property: keyof Rule,\n) {\n    if (!property && typeof console !== \"undefined\") {\n        console.warn(\n            \"simple-markdown ruleOutput should take 'react' or \" +\n                \"'html' as the second argument.\",\n        );\n    }\n\n    var nestedRuleOutput = function (\n        ast: SingleASTNode,\n        outputFunc: Output<any>,\n        state: State,\n    ) {\n        // @ts-expect-error - TS2349 - This expression is not callable.\n        //   Type 'unknown' has no call signatures.\n        return rules[ast.type][property](ast, outputFunc, state);\n    };\n    return nestedRuleOutput;\n};\n\n/** (deprecated)\n */\nvar reactFor = function (outputFunc: ReactNodeOutput): ReactOutput {\n    var nestedOutput: ReactOutput = function (ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            var oldKey = state.key;\n            var result: Array<ReactElements> = [];\n\n            // map nestedOutput over the ast, except group any text\n            // nodes together into a single string output.\n            var lastResult = null;\n            for (var i = 0; i < ast.length; i++) {\n                state.key = \"\" + i;\n                var nodeOut = nestedOutput(ast[i], state);\n                if (\n                    typeof nodeOut === \"string\" &&\n                    typeof lastResult === \"string\"\n                ) {\n                    // @ts-expect-error - TS2322 - Type 'string' is not assignable to type 'null'.\n                    lastResult = lastResult + nodeOut;\n                    result[result.length - 1] = lastResult;\n                } else {\n                    result.push(nodeOut);\n                    // @ts-expect-error - TS2322 - Type 'ReactNode' is not assignable to type 'null'.\n                    lastResult = nodeOut;\n                }\n            }\n\n            state.key = oldKey;\n            return result;\n        } else {\n            return outputFunc(ast, nestedOutput, state);\n        }\n    };\n    return nestedOutput;\n};\n\n/** (deprecated)\n */\nvar htmlFor = function (outputFunc: HtmlNodeOutput): HtmlOutput {\n    var nestedOutput: HtmlOutput = function (ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            return ast\n                .map(function (node) {\n                    return nestedOutput(node, state);\n                })\n                .join(\"\");\n        } else {\n            return outputFunc(ast, nestedOutput, state);\n        }\n    };\n    return nestedOutput;\n};\n\nvar outputFor = function <Rule>(\n    rules: OutputRules<Rule>,\n    property: keyof Rule,\n    defaultState: State | null = {},\n) {\n    if (!property) {\n        throw new Error(\n            \"simple-markdown: outputFor: `property` must be \" +\n                \"defined. \" +\n                \"if you just upgraded, you probably need to replace `outputFor` \" +\n                \"with `reactFor`\",\n        );\n    }\n\n    var latestState: State;\n    var arrayRule: ArrayRule = rules.Array || defaultRules.Array;\n\n    // Tricks to convince tsc that this var is not null:\n    // @ts-expect-error - TS2538 - Type 'symbol' cannot be used as an index type.\n    var arrayRuleCheck = arrayRule[property];\n    if (!arrayRuleCheck) {\n        throw new Error(\n            \"simple-markdown: outputFor: to join nodes of type `\" +\n                // @ts-expect-error - TS2469 - The '+' operator cannot be applied to type 'symbol'.\n                property +\n                \"` you must provide an `Array:` joiner rule with that type, \" +\n                \"Please see the docs for details on specifying an Array rule.\",\n        );\n    }\n    var arrayRuleOutput = arrayRuleCheck;\n\n    var nestedOutput: Output<any> = function (ast, state) {\n        state = state || latestState;\n        latestState = state;\n        if (Array.isArray(ast)) {\n            return arrayRuleOutput(ast, nestedOutput, state);\n        } else {\n            // @ts-expect-error - TS2349 - This expression is not callable.\n            //   Type 'unknown' has no call signatures.\n            return rules[ast.type][property](ast, nestedOutput, state);\n        }\n    };\n\n    var outerOutput: Output<any> = function (ast, state) {\n        latestState = populateInitialState(state, defaultState);\n        return nestedOutput(ast, latestState);\n    };\n    return outerOutput;\n};\n\n// @ts-expect-error - TS2345 - Argument of type 'DefaultRules' is not assignable to parameter of type 'ParserRules'.\nvar defaultRawParse = parserFor(defaultRules);\n\nvar defaultBlockParse = function (\n    source: string,\n    state?: State | null,\n): Array<SingleASTNode> {\n    state = state || {};\n    state.inline = false;\n    return defaultRawParse(source, state);\n};\n\nvar defaultInlineParse = function (\n    source: string,\n    state?: State | null,\n): Array<SingleASTNode> {\n    state = state || {};\n    state.inline = true;\n    return defaultRawParse(source, state);\n};\n\nvar defaultImplicitParse = function (\n    source: string,\n    state?: State | null,\n): Array<SingleASTNode> {\n    var isBlock = BLOCK_END_R.test(source);\n    state = state || {};\n    state.inline = !isBlock;\n    return defaultRawParse(source, state);\n};\n\nvar defaultReactOutput: ReactOutput = outputFor(defaultRules, \"react\");\nvar defaultHtmlOutput: HtmlOutput = outputFor(defaultRules, \"html\");\n\nvar markdownToReact = function (\n    source: string,\n    state?: State | null,\n): ReactElements {\n    return defaultReactOutput(defaultBlockParse(source, state), state);\n};\n\nvar markdownToHtml = function (source: string, state?: State | null): string {\n    return defaultHtmlOutput(defaultBlockParse(source, state), state);\n};\n\n// TODO: This needs definition\ntype Props = any;\nvar ReactMarkdown = function (props: Props): React.ReactElement {\n    var divProps: Record<string, any> = {};\n\n    for (var prop in props) {\n        if (\n            prop !== \"source\" &&\n            Object.prototype.hasOwnProperty.call(props, prop)\n        ) {\n            divProps[prop] = props[prop];\n        }\n    }\n    divProps.children = markdownToReact(props.source);\n\n    return reactElement(\"div\", null, divProps);\n};\n\ntype Exports = {\n    readonly defaultRules: DefaultRules;\n    readonly parserFor: (\n        rules: ParserRules,\n        defaultState?: State | null | undefined,\n    ) => Parser;\n    readonly outputFor: <Rule>(\n        rules: OutputRules<Rule>,\n        param: keyof Rule,\n        defaultState?: State | null | undefined,\n    ) => Output<any>;\n    readonly ruleOutput: <Rule>(\n        rules: OutputRules<Rule>,\n        param: keyof Rule,\n    ) => NodeOutput<any>;\n    readonly reactFor: (arg1: ReactNodeOutput) => ReactOutput;\n    readonly htmlFor: (arg1: HtmlNodeOutput) => HtmlOutput;\n    readonly inlineRegex: (regex: RegExp) => MatchFunction;\n    readonly blockRegex: (regex: RegExp) => MatchFunction;\n    readonly anyScopeRegex: (regex: RegExp) => MatchFunction;\n    readonly parseInline: (\n        parse: Parser,\n        content: string,\n        state: State,\n    ) => ASTNode;\n    readonly parseBlock: (\n        parse: Parser,\n        content: string,\n        state: State,\n    ) => ASTNode;\n    readonly markdownToReact: (\n        source: string,\n        state?: State | null | undefined,\n    ) => ReactElements;\n    readonly markdownToHtml: (\n        source: string,\n        state?: State | null | undefined,\n    ) => string;\n    readonly ReactMarkdown: (props: {\n        source: string;\n        [key: string]: any;\n    }) => ReactElement;\n    readonly defaultRawParse: (\n        source: string,\n        state?: State | null | undefined,\n    ) => Array<SingleASTNode>;\n    readonly defaultBlockParse: (\n        source: string,\n        state?: State | null | undefined,\n    ) => Array<SingleASTNode>;\n    readonly defaultInlineParse: (\n        source: string,\n        state?: State | null | undefined,\n    ) => Array<SingleASTNode>;\n    readonly defaultImplicitParse: (\n        source: string,\n        state?: State | null | undefined,\n    ) => Array<SingleASTNode>;\n    readonly defaultReactOutput: ReactOutput;\n    readonly defaultHtmlOutput: HtmlOutput;\n    readonly preprocess: (source: string) => string;\n    readonly sanitizeText: (text: Attr) => string;\n    readonly sanitizeUrl: (\n        url?: string | null | undefined,\n    ) => string | null | undefined;\n    readonly unescapeUrl: (url: string) => string;\n    readonly htmlTag: (\n        tagName: string,\n        content: string,\n        attributes?:\n            | Partial<Record<any, Attr | null | undefined>>\n            | null\n            | undefined,\n        isClosed?: boolean | null | undefined,\n    ) => string;\n    readonly reactElement: (\n        type: string,\n        key: string | null,\n        props: {\n            [key: string]: any;\n        },\n    ) => ReactElement;\n    /**\n     * defaultParse is deprecated, please use `defaultImplicitParse`\n     * @deprecated\n     */\n    readonly defaultParse: (...args: any[]) => any;\n    /**\n     * defaultOutput is deprecated, please use `defaultReactOutput`\n     * @deprecated\n     */\n    readonly defaultOutput: (...args: any[]) => any;\n};\n\nexport type {\n    // Hopefully you shouldn't have to use these, but they're here if you need!\n    // Top-level API:\n    State,\n    Parser,\n    Output,\n    ReactOutput,\n    HtmlOutput,\n    // Most of the following types should be considered experimental and\n    // subject to change or change names. Again, they shouldn't be necessary,\n    // but if they are I'd love to hear how so I can better support them!\n\n    // Individual Rule fields:\n    Capture,\n    MatchFunction,\n    ParseFunction,\n    NodeOutput,\n    ArrayNodeOutput,\n    ReactNodeOutput,\n    // Single rules:\n    ParserRule,\n    ReactOutputRule,\n    HtmlOutputRule,\n    // Sets of rules:\n    ParserRules,\n    OutputRules,\n    Rules,\n    ReactRules,\n    HtmlRules,\n    SingleASTNode,\n};\n\nvar SimpleMarkdown: Exports = {\n    defaultRules: defaultRules,\n    parserFor: parserFor,\n    outputFor: outputFor,\n\n    inlineRegex: inlineRegex,\n    blockRegex: blockRegex,\n    anyScopeRegex: anyScopeRegex,\n    parseInline: parseInline,\n    parseBlock: parseBlock,\n\n    // default wrappers:\n    markdownToReact: markdownToReact,\n    markdownToHtml: markdownToHtml,\n    ReactMarkdown: ReactMarkdown,\n\n    defaultBlockParse: defaultBlockParse,\n    defaultInlineParse: defaultInlineParse,\n    defaultImplicitParse: defaultImplicitParse,\n\n    defaultReactOutput: defaultReactOutput,\n    defaultHtmlOutput: defaultHtmlOutput,\n\n    preprocess: preprocess,\n    sanitizeText: sanitizeText,\n    sanitizeUrl: sanitizeUrl,\n    unescapeUrl: unescapeUrl,\n    htmlTag: htmlTag,\n    reactElement: reactElement,\n\n    // deprecated:\n    defaultRawParse: defaultRawParse,\n    ruleOutput: ruleOutput,\n    reactFor: reactFor,\n    htmlFor: htmlFor,\n\n    defaultParse: function (...args) {\n        if (typeof console !== \"undefined\") {\n            console.warn(\n                \"defaultParse is deprecated, please use `defaultImplicitParse`\",\n            );\n        }\n        // @ts-expect-error - Argument of type 'any[]' is not assignable to parameter of type '[node: ASTNode, state?: State | null | undefined]'. Target requires 1 element(s) but source may have fewer.\n        return defaultImplicitParse.apply(null, args);\n    },\n    defaultOutput: function (...args) {\n        if (typeof console !== \"undefined\") {\n            console.warn(\n                \"defaultOutput is deprecated, please use `defaultReactOutput`\",\n            );\n        }\n        // @ts-expect-error - Argument of type 'any[]' is not assignable to parameter of type '[node: ASTNode, state?: State | null | undefined]'. Target requires 1 element(s) but source may have fewer.\n        return defaultReactOutput.apply(null, args);\n    },\n};\n\nexport default SimpleMarkdown;\n"],"names":["libName","libVersion","addLibraryVersionToPerseusDebug","CR_NEWLINE_R","TAB_R","FORMFEED_R","preprocess","source","replace","populateInitialState","givenState","defaultState","state","prop","Object","prototype","hasOwnProperty","call","parserFor","rules","ruleList","keys","filter","type","rule","match","order","isFinite","console","warn","String","sort","typeA","typeB","ruleA","ruleB","orderA","orderB","secondaryOrderA","quality","secondaryOrderB","latestState","nestedParse","result","ruleType","capture","NaN","i","currRuleType","currRule","currOrder","prevCaptureStr","prevCapture","currCapture","currQuality","Error","length","index","parsed","parse","Array","isArray","push","apply","substring","outerParse","inline","disableAutoBlockNewlines","inlineRegex","regex","exec","blockRegex","anyScopeRegex","TYPE_SYMBOL","Symbol","for","reactElement","key","props","element","$$typeof","undefined","ref","_owner","htmlTag","tagName","content","attributes","isClosed","attributeString","attr","attribute","sanitizeText","unclosedTag","EMPTY_PROPS","sanitizeUrl","url","prot","URL","protocol","indexOf","SANITIZE_TEXT_R","SANITIZE_TEXT_CODES","text","chr","UNESCAPE_URL_R","unescapeUrl","rawUrlString","parseInline","isCurrentlyInline","parseBlock","parseCaptureInline","ignoreCapture","LIST_BULLET","LIST_ITEM_PREFIX","LIST_ITEM_PREFIX_R","RegExp","LIST_ITEM_R","BLOCK_END_R","INLINE_CODE_ESCAPE_BACKTICKS_R","LIST_BLOCK_END_R","LIST_ITEM_END_R","LIST_R","LIST_LOOKBEHIND_R","TABLES","TABLE_ROW_SEPARATOR_TRIM","TABLE_CELL_END_TRIM","TABLE_RIGHT_ALIGN","TABLE_CENTER_ALIGN","TABLE_LEFT_ALIGN","parseTableAlignCapture","alignCapture","test","parseTableAlign","trimEndSeparators","alignText","trim","split","map","parseTableRow","prevInTable","inTable","tableRow","cells","forEach","node","parseTableCells","rowsText","rowText","parseTable","header","align","parseNpTable","TABLE_REGEX","NPTABLE_REGEX","LINK_INSIDE","LINK_HREF_AND_TITLE","AUTOLINK_MAILTO_CHECK_R","parseRef","refNode","toLowerCase","_defs","def","target","title","_refs","defaultRules","react","arr","output","oldKey","html","heading","level","children","nptable","lheading","hr","codeBlock","lang","className","class","fence","blockQuote","list","isStartOfLineCapture","isListBlock","_list","bullet","ordered","start","items","lastItemWasAParagraph","itemContent","item","prefixCapture","space","spaceRegex","isLastItem","containsBlocks","thisItemIsAParagraph","oldStateInline","oldStateList","adjustedContent","ListWrapper","listItems","join","listTag","table","getStyle","colIndex","textAlign","headers","style","scope","rows","row","r","c","cols","thead","tbody","newline","paragraph","escape","tableSeparator","autolink","mailto","address","link","href","image","alt","src","reflink","refimage","em","strong","u","del","inlineCode","br","ruleOutput","property","nestedRuleOutput","ast","outputFunc","reactFor","nestedOutput","lastResult","nodeOut","htmlFor","outputFor","arguments","arrayRule","arrayRuleCheck","arrayRuleOutput","outerOutput","defaultRawParse","defaultBlockParse","defaultInlineParse","defaultImplicitParse","isBlock","defaultReactOutput","defaultHtmlOutput","markdownToReact","markdownToHtml","ReactMarkdown","divProps","SimpleMarkdown","defaultParse","_len","args","_key","defaultOutput","_len2","_key2"],"mappings":"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"}