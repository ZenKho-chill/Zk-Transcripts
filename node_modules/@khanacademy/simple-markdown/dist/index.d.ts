/**
 * Simple-Markdown
 * ===============
 *
 * Simple-Markdown's primary goal is to be easy to adapt. It aims
 * to be compliant with John Gruber's [Markdown Syntax page][1],
 * but compatiblity with other markdown implementations' edge-cases
 * will be sacrificed where it conflicts with simplicity or
 * extensibility.
 *
 * If your goal is to simply embed a standard markdown implementation
 * in your website, simple-markdown is probably not the best library
 * for you (although it should work). But if you have struggled to
 * customize an existing library to meet your needs, simple-markdown
 * might be able to help.
 *
 * Many of the regexes and original logic has been adapted from
 * the wonderful [marked.js](https://github.com/chjj/marked)
 */
import type { Capture, MatchFunction, State } from "./troublesome-types";
import type * as React from "react";
export { libVersion } from "./version";
type Attr = string | number | boolean | null | undefined;
type SingleASTNode = {
    type: string;
    [key: string]: any;
};
type UnTypedASTNode = {
    [key: string]: any;
};
type ASTNode = SingleASTNode | Array<SingleASTNode>;
type ReactElement = React.ReactElement<any>;
type ReactElements = React.ReactNode;
type Parser = (source: string, state?: State | null | undefined) => Array<SingleASTNode>;
type ParseFunction = (capture: Capture, nestedParse: Parser, state: State) => UnTypedASTNode | ASTNode;
type SingleNodeParseFunction = (capture: Capture, nestedParse: Parser, state: State) => UnTypedASTNode;
type Output<Result> = (node: ASTNode, state?: State | null | undefined) => Result;
type NodeOutput<Result> = (node: SingleASTNode, nestedOutput: Output<Result>, state: State) => Result;
type ArrayNodeOutput<Result> = (node: Array<SingleASTNode>, nestedOutput: Output<Result>, state: State) => Result;
type ReactOutput = Output<ReactElements>;
type ReactNodeOutput = NodeOutput<ReactElements>;
type HtmlOutput = Output<string>;
type HtmlNodeOutput = NodeOutput<string>;
type ParserRule = {
    readonly order: number;
    readonly match: MatchFunction;
    readonly quality?: (capture: Capture, state: State, prevCapture: string) => number;
    readonly parse: ParseFunction;
};
type SingleNodeParserRule = {
    readonly order: number;
    readonly match: MatchFunction;
    readonly quality?: (capture: Capture, state: State, prevCapture: string) => number;
    readonly parse: SingleNodeParseFunction;
};
type ReactOutputRule = {
    readonly react: ReactNodeOutput | null;
};
type HtmlOutputRule = {
    readonly html: HtmlNodeOutput | null;
};
type ArrayRule = {
    readonly react?: ArrayNodeOutput<ReactElements>;
    readonly html?: ArrayNodeOutput<string>;
    readonly [key: string]: ArrayNodeOutput<any>;
};
type ParserRules = {
    readonly Array?: ArrayRule;
    readonly [type: string]: ParserRule;
};
type OutputRules<Rule> = {
    readonly Array?: ArrayRule;
    readonly [type: string]: Rule;
};
type Rules<OutputRule> = {
    readonly Array?: ArrayRule;
    readonly [type: string]: ParserRule & OutputRule;
};
type ReactRules = {
    readonly Array?: {
        readonly react: ArrayNodeOutput<ReactElements>;
    };
    readonly [type: string]: ParserRule & ReactOutputRule;
};
type HtmlRules = {
    readonly Array?: {
        readonly html: ArrayNodeOutput<string>;
    };
    readonly [type: string]: ParserRule & HtmlOutputRule;
};
type NonNullReactOutputRule = {
    readonly react: ReactNodeOutput;
};
type ElementReactOutputRule = {
    readonly react: NodeOutput<ReactElement>;
};
type TextReactOutputRule = {
    readonly react: NodeOutput<string>;
};
type NonNullHtmlOutputRule = {
    readonly html: HtmlNodeOutput;
};
type DefaultInRule = SingleNodeParserRule & ReactOutputRule & HtmlOutputRule;
type TextInOutRule = SingleNodeParserRule & TextReactOutputRule & NonNullHtmlOutputRule;
type LenientInOutRule = SingleNodeParserRule & NonNullReactOutputRule & NonNullHtmlOutputRule;
type DefaultInOutRule = SingleNodeParserRule & ElementReactOutputRule & NonNullHtmlOutputRule;
type DefaultRules = {
    readonly Array: {
        readonly react: ArrayNodeOutput<ReactElements>;
        readonly html: ArrayNodeOutput<string>;
    };
    readonly heading: DefaultInOutRule;
    readonly nptable: DefaultInRule;
    readonly lheading: DefaultInRule;
    readonly hr: DefaultInOutRule;
    readonly codeBlock: DefaultInOutRule;
    readonly fence: DefaultInRule;
    readonly blockQuote: DefaultInOutRule;
    readonly list: DefaultInOutRule;
    readonly def: LenientInOutRule;
    readonly table: DefaultInOutRule;
    readonly tableSeparator: DefaultInRule;
    readonly newline: TextInOutRule;
    readonly paragraph: DefaultInOutRule;
    readonly escape: DefaultInRule;
    readonly autolink: DefaultInRule;
    readonly mailto: DefaultInRule;
    readonly url: DefaultInRule;
    readonly link: DefaultInOutRule;
    readonly image: DefaultInOutRule;
    readonly reflink: DefaultInRule;
    readonly refimage: DefaultInRule;
    readonly em: DefaultInOutRule;
    readonly strong: DefaultInOutRule;
    readonly u: DefaultInOutRule;
    readonly del: DefaultInOutRule;
    readonly inlineCode: DefaultInOutRule;
    readonly br: DefaultInOutRule;
    readonly text: TextInOutRule;
};
type Exports = {
    readonly defaultRules: DefaultRules;
    readonly parserFor: (rules: ParserRules, defaultState?: State | null | undefined) => Parser;
    readonly outputFor: <Rule>(rules: OutputRules<Rule>, param: keyof Rule, defaultState?: State | null | undefined) => Output<any>;
    readonly ruleOutput: <Rule>(rules: OutputRules<Rule>, param: keyof Rule) => NodeOutput<any>;
    readonly reactFor: (arg1: ReactNodeOutput) => ReactOutput;
    readonly htmlFor: (arg1: HtmlNodeOutput) => HtmlOutput;
    readonly inlineRegex: (regex: RegExp) => MatchFunction;
    readonly blockRegex: (regex: RegExp) => MatchFunction;
    readonly anyScopeRegex: (regex: RegExp) => MatchFunction;
    readonly parseInline: (parse: Parser, content: string, state: State) => ASTNode;
    readonly parseBlock: (parse: Parser, content: string, state: State) => ASTNode;
    readonly markdownToReact: (source: string, state?: State | null | undefined) => ReactElements;
    readonly markdownToHtml: (source: string, state?: State | null | undefined) => string;
    readonly ReactMarkdown: (props: {
        source: string;
        [key: string]: any;
    }) => ReactElement;
    readonly defaultRawParse: (source: string, state?: State | null | undefined) => Array<SingleASTNode>;
    readonly defaultBlockParse: (source: string, state?: State | null | undefined) => Array<SingleASTNode>;
    readonly defaultInlineParse: (source: string, state?: State | null | undefined) => Array<SingleASTNode>;
    readonly defaultImplicitParse: (source: string, state?: State | null | undefined) => Array<SingleASTNode>;
    readonly defaultReactOutput: ReactOutput;
    readonly defaultHtmlOutput: HtmlOutput;
    readonly preprocess: (source: string) => string;
    readonly sanitizeText: (text: Attr) => string;
    readonly sanitizeUrl: (url?: string | null | undefined) => string | null | undefined;
    readonly unescapeUrl: (url: string) => string;
    readonly htmlTag: (tagName: string, content: string, attributes?: Partial<Record<any, Attr | null | undefined>> | null | undefined, isClosed?: boolean | null | undefined) => string;
    readonly reactElement: (type: string, key: string | null, props: {
        [key: string]: any;
    }) => ReactElement;
    /**
     * defaultParse is deprecated, please use `defaultImplicitParse`
     * @deprecated
     */
    readonly defaultParse: (...args: any[]) => any;
    /**
     * defaultOutput is deprecated, please use `defaultReactOutput`
     * @deprecated
     */
    readonly defaultOutput: (...args: any[]) => any;
};
export type { State, Parser, Output, ReactOutput, HtmlOutput, Capture, MatchFunction, ParseFunction, NodeOutput, ArrayNodeOutput, ReactNodeOutput, ParserRule, ReactOutputRule, HtmlOutputRule, ParserRules, OutputRules, Rules, ReactRules, HtmlRules, SingleASTNode, };
declare var SimpleMarkdown: Exports;
export default SimpleMarkdown;
