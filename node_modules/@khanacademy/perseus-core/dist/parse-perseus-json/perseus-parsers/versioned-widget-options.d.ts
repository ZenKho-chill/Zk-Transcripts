import type { Version } from "../../data-schema";
import type { Parser } from "../parser-types";
type Versioned = {
    version?: Version;
};
/**
 * Creates a parser for a widget options type with multiple major versions. Old
 * versions are migrated to the latest version. The parse fails if the input
 * data does not match any of the versions.
 *
 * @example
 * const parseOptions = versionedWidgetOptions(3, parseOptionsV3)
 *     .withMigrationFrom(2, parseOptionsV2, migrateV2ToV3)
 *     .withMigrationFrom(1, parseOptionsV1, migrateV1ToV2)
 *     .withMigrationFrom(0, parseOptionsV0, migrateV0ToV1)
 *     .parser;
 *
 * @param latestMajorVersion the latest major version of the widget options.
 * @param parseLatest a {@link Parser} for the latest version of the widget
 * options.
 * @returns a builder object, to which migrations from earlier versions can be
 * added. Migrations must be added in "reverse chronological" order as in the
 * example above.
 */
export declare function versionedWidgetOptions<Latest extends Versioned>(latestMajorVersion: number, parseLatest: Parser<Latest>): VersionedWidgetOptionsParserBuilder<Latest, Latest>;
declare class VersionedWidgetOptionsParserBuilder<Latest extends Versioned, MigratableWidgetOptions extends Versioned> {
    private migrateToLatest;
    private parseOtherVersions;
    parser: Parser<Latest>;
    constructor(majorVersion: number, parseThisVersion: Parser<MigratableWidgetOptions>, migrateToLatest: (m: MigratableWidgetOptions) => Latest, parseOtherVersions: Parser<Latest>);
    /**
     * Add a migration from an old version of the widget options.
     */
    withMigrationFrom<Old extends Versioned>(majorVersion: number, parseOldVersion: Parser<Old>, migrateToNextVersion: (old: Old) => MigratableWidgetOptions): VersionedWidgetOptionsParserBuilder<Latest, Old>;
}
export {};
