export type Result<S, F> = Success<S> | Failure<F>;
export type Success<T> = {
    type: "success";
    value: T;
};
export type Failure<T> = {
    type: "failure";
    detail: T;
};
export declare function success<T>(value: T): Success<T>;
export declare function failure<T>(detail: T): Failure<T>;
export declare function isFailure<S, F>(result: Result<S, F>): result is Failure<F>;
export declare function isSuccess<S, F>(result: Result<S, F>): result is Success<S>;
export declare function assertFailure<S, F>(result: Result<S, F>): asserts result is Failure<F>;
export declare function assertSuccess<S, F>(result: Result<S, F>): asserts result is Success<S>;
/**
 * @returns a function that transforms the `detail` value of any Failure result
 * passed to it, and leaves Success results unchanged. `mapFailure` is curried
 * for easy composition with Array.map(), mu-lambda's pipe(), etc.
 * @param f the function to apply to Failure `detail`s.
 */
export declare function mapFailure<S, DetailIn, DetailOut>(f: (detail: DetailIn) => DetailOut): (result: Result<S, DetailIn>) => Result<S, DetailOut>;
export declare function all<S, F>(results: Array<Result<S, F>>, combineFailureDetails?: (a: F, b: F) => F): Result<S[], F>;
