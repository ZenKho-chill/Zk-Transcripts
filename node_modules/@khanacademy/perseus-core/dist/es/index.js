import { seededRNG as seededRNG$1, shuffle as shuffle$2 } from '@khanacademy/perseus-core';

/**
 * Adds the given perseus library version information to the __perseus_debug__
 * object and ensures that the object is attached to `globalThis` (`window` in
 * browser environments).
 *
 * This allows each library to provide runtime version information to assist in
 * debugging in production environments.
 */
const addLibraryVersionToPerseusDebug = (libraryName, libraryVersion) => {
  // If the library version is the default value, then we don't want to
  // prefix it with a "v" to indicate that it is a version number.
  let prefix = "v";
  if (libraryVersion === "__lib_version__") {
    prefix = "";
  }
  const formattedVersion = `${prefix}${libraryVersion}`;
  if (typeof globalThis !== "undefined") {
    var _globalThis$__perseus;
    globalThis.__perseus_debug__ = (_globalThis$__perseus = globalThis.__perseus_debug__) != null ? _globalThis$__perseus : {};
    const existingVersionEntry = globalThis.__perseus_debug__[libraryName];
    if (existingVersionEntry) {
      // If we already have an entry and it doesn't match the registered
      // version, we morph the entry into an array and log a warning.
      if (existingVersionEntry !== formattedVersion) {
        // Existing entry might be an array already (oops, at least 2
        // versions of the library already loaded!).
        const allVersions = Array.isArray(existingVersionEntry) ? existingVersionEntry : [existingVersionEntry];
        allVersions.push(formattedVersion);
        globalThis.__perseus_debug__[libraryName] = allVersions;

        // eslint-disable-next-line no-console
        console.warn(`Multiple versions of ${libraryName} loaded on this page: ${allVersions.sort().join(", ")}`);
      }
    } else {
      globalThis.__perseus_debug__[libraryName] = formattedVersion;
    }
  } else {
    // eslint-disable-next-line no-console
    console.warn(`globalThis not found found (${formattedVersion})`);
  }
};

// Current version.
var VERSION = '1.13.3';

// Establish the root object, `window` (`self`) in the browser, `global`
// on the server, or `this` in some virtual machines. We use `self`
// instead of `window` for `WebWorker` support.
var root = (typeof self == 'object' && self.self === self && self) ||
          (typeof global == 'object' && global.global === global && global) ||
          Function('return this')() ||
          {};

// Save bytes in the minified (but not gzipped) version:
var ArrayProto = Array.prototype, ObjProto = Object.prototype;
var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

// Create quick reference variables for speed access to core prototypes.
var push = ArrayProto.push,
    slice = ArrayProto.slice,
    toString = ObjProto.toString,
    hasOwnProperty = ObjProto.hasOwnProperty;

// Modern feature detection.
var supportsArrayBuffer = typeof ArrayBuffer !== 'undefined',
    supportsDataView = typeof DataView !== 'undefined';

// All **ECMAScript 5+** native function implementations that we hope to use
// are declared here.
var nativeIsArray = Array.isArray,
    nativeKeys = Object.keys,
    nativeCreate = Object.create,
    nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;

// Create references to these builtin functions because we override them.
var _isNaN = isNaN,
    _isFinite = isFinite;

// Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
  'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

// The largest integer that can be represented exactly.
var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;

// Some functions take a variable number of arguments, or a few expected
// arguments at the beginning and then a variable number of values to operate
// on. This helper accumulates all remaining arguments past the function’s
// argument length (or an explicit `startIndex`), into an array that becomes
// the last argument. Similar to ES6’s "rest parameter".
function restArguments(func, startIndex) {
  startIndex = startIndex == null ? func.length - 1 : +startIndex;
  return function() {
    var length = Math.max(arguments.length - startIndex, 0),
        rest = Array(length),
        index = 0;
    for (; index < length; index++) {
      rest[index] = arguments[index + startIndex];
    }
    switch (startIndex) {
      case 0: return func.call(this, rest);
      case 1: return func.call(this, arguments[0], rest);
      case 2: return func.call(this, arguments[0], arguments[1], rest);
    }
    var args = Array(startIndex + 1);
    for (index = 0; index < startIndex; index++) {
      args[index] = arguments[index];
    }
    args[startIndex] = rest;
    return func.apply(this, args);
  };
}

// Is a given variable an object?
function isObject$1(obj) {
  var type = typeof obj;
  return type === 'function' || (type === 'object' && !!obj);
}

// Is a given value equal to null?
function isNull(obj) {
  return obj === null;
}

// Is a given variable undefined?
function isUndefined(obj) {
  return obj === void 0;
}

// Is a given value a boolean?
function isBoolean(obj) {
  return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
}

// Is a given value a DOM element?
function isElement(obj) {
  return !!(obj && obj.nodeType === 1);
}

// Internal function for creating a `toString`-based type tester.
function tagTester(name) {
  var tag = '[object ' + name + ']';
  return function(obj) {
    return toString.call(obj) === tag;
  };
}

var isString = tagTester('String');

var isNumber = tagTester('Number');

var isDate = tagTester('Date');

var isRegExp = tagTester('RegExp');

var isError = tagTester('Error');

var isSymbol = tagTester('Symbol');

var isArrayBuffer = tagTester('ArrayBuffer');

var isFunction = tagTester('Function');

// Optimize `isFunction` if appropriate. Work around some `typeof` bugs in old
// v8, IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
var nodelist = root.document && root.document.childNodes;
if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {
  isFunction = function(obj) {
    return typeof obj == 'function' || false;
  };
}

var isFunction$1 = isFunction;

var hasObjectTag = tagTester('Object');

// In IE 10 - Edge 13, `DataView` has string tag `'[object Object]'`.
// In IE 11, the most common among them, this problem also applies to
// `Map`, `WeakMap` and `Set`.
var hasStringTagBug = (
      supportsDataView && hasObjectTag(new DataView(new ArrayBuffer(8)))
    ),
    isIE11 = (typeof Map !== 'undefined' && hasObjectTag(new Map));

var isDataView = tagTester('DataView');

// In IE 10 - Edge 13, we need a different heuristic
// to determine whether an object is a `DataView`.
function ie10IsDataView(obj) {
  return obj != null && isFunction$1(obj.getInt8) && isArrayBuffer(obj.buffer);
}

var isDataView$1 = (hasStringTagBug ? ie10IsDataView : isDataView);

// Is a given value an array?
// Delegates to ECMA5's native `Array.isArray`.
var isArray = nativeIsArray || tagTester('Array');

// Internal function to check whether `key` is an own property name of `obj`.
function has$1(obj, key) {
  return obj != null && hasOwnProperty.call(obj, key);
}

var isArguments = tagTester('Arguments');

// Define a fallback version of the method in browsers (ahem, IE < 9), where
// there isn't any inspectable "Arguments" type.
(function() {
  if (!isArguments(arguments)) {
    isArguments = function(obj) {
      return has$1(obj, 'callee');
    };
  }
}());

var isArguments$1 = isArguments;

// Is a given object a finite number?
function isFinite$1(obj) {
  return !isSymbol(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
}

// Is the given value `NaN`?
function isNaN$1(obj) {
  return isNumber(obj) && _isNaN(obj);
}

// Predicate-generating function. Often useful outside of Underscore.
function constant$1(value) {
  return function() {
    return value;
  };
}

// Common internal logic for `isArrayLike` and `isBufferLike`.
function createSizePropertyCheck(getSizeProperty) {
  return function(collection) {
    var sizeProperty = getSizeProperty(collection);
    return typeof sizeProperty == 'number' && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
  }
}

// Internal helper to generate a function to obtain property `key` from `obj`.
function shallowProperty(key) {
  return function(obj) {
    return obj == null ? void 0 : obj[key];
  };
}

// Internal helper to obtain the `byteLength` property of an object.
var getByteLength = shallowProperty('byteLength');

// Internal helper to determine whether we should spend extensive checks against
// `ArrayBuffer` et al.
var isBufferLike = createSizePropertyCheck(getByteLength);

// Is a given value a typed array?
var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
function isTypedArray(obj) {
  // `ArrayBuffer.isView` is the most future-proof, so use it when available.
  // Otherwise, fall back on the above regular expression.
  return nativeIsView ? (nativeIsView(obj) && !isDataView$1(obj)) :
                isBufferLike(obj) && typedArrayPattern.test(toString.call(obj));
}

var isTypedArray$1 = supportsArrayBuffer ? isTypedArray : constant$1(false);

// Internal helper to obtain the `length` property of an object.
var getLength = shallowProperty('length');

// Internal helper to create a simple lookup structure.
// `collectNonEnumProps` used to depend on `_.contains`, but this led to
// circular imports. `emulatedSet` is a one-off solution that only works for
// arrays of strings.
function emulatedSet(keys) {
  var hash = {};
  for (var l = keys.length, i = 0; i < l; ++i) hash[keys[i]] = true;
  return {
    contains: function(key) { return hash[key] === true; },
    push: function(key) {
      hash[key] = true;
      return keys.push(key);
    }
  };
}

// Internal helper. Checks `keys` for the presence of keys in IE < 9 that won't
// be iterated by `for key in ...` and thus missed. Extends `keys` in place if
// needed.
function collectNonEnumProps(obj, keys) {
  keys = emulatedSet(keys);
  var nonEnumIdx = nonEnumerableProps.length;
  var constructor = obj.constructor;
  var proto = (isFunction$1(constructor) && constructor.prototype) || ObjProto;

  // Constructor is a special case.
  var prop = 'constructor';
  if (has$1(obj, prop) && !keys.contains(prop)) keys.push(prop);

  while (nonEnumIdx--) {
    prop = nonEnumerableProps[nonEnumIdx];
    if (prop in obj && obj[prop] !== proto[prop] && !keys.contains(prop)) {
      keys.push(prop);
    }
  }
}

// Retrieve the names of an object's own properties.
// Delegates to **ECMAScript 5**'s native `Object.keys`.
function keys(obj) {
  if (!isObject$1(obj)) return [];
  if (nativeKeys) return nativeKeys(obj);
  var keys = [];
  for (var key in obj) if (has$1(obj, key)) keys.push(key);
  // Ahem, IE < 9.
  if (hasEnumBug) collectNonEnumProps(obj, keys);
  return keys;
}

// Is a given array, string, or object empty?
// An "empty" object has no enumerable own-properties.
function isEmpty(obj) {
  if (obj == null) return true;
  // Skip the more expensive `toString`-based type checks if `obj` has no
  // `.length`.
  var length = getLength(obj);
  if (typeof length == 'number' && (
    isArray(obj) || isString(obj) || isArguments$1(obj)
  )) return length === 0;
  return getLength(keys(obj)) === 0;
}

// Returns whether an object has a given set of `key:value` pairs.
function isMatch(object, attrs) {
  var _keys = keys(attrs), length = _keys.length;
  if (object == null) return !length;
  var obj = Object(object);
  for (var i = 0; i < length; i++) {
    var key = _keys[i];
    if (attrs[key] !== obj[key] || !(key in obj)) return false;
  }
  return true;
}

// If Underscore is called as a function, it returns a wrapped object that can
// be used OO-style. This wrapper holds altered versions of all functions added
// through `_.mixin`. Wrapped objects may be chained.
function _$1(obj) {
  if (obj instanceof _$1) return obj;
  if (!(this instanceof _$1)) return new _$1(obj);
  this._wrapped = obj;
}

_$1.VERSION = VERSION;

// Extracts the result from a wrapped and chained object.
_$1.prototype.value = function() {
  return this._wrapped;
};

// Provide unwrapping proxies for some methods used in engine operations
// such as arithmetic and JSON stringification.
_$1.prototype.valueOf = _$1.prototype.toJSON = _$1.prototype.value;

_$1.prototype.toString = function() {
  return String(this._wrapped);
};

// Internal function to wrap or shallow-copy an ArrayBuffer,
// typed array or DataView to a new view, reusing the buffer.
function toBufferView(bufferSource) {
  return new Uint8Array(
    bufferSource.buffer || bufferSource,
    bufferSource.byteOffset || 0,
    getByteLength(bufferSource)
  );
}

// We use this string twice, so give it a name for minification.
var tagDataView = '[object DataView]';

// Internal recursive comparison function for `_.isEqual`.
function eq(a, b, aStack, bStack) {
  // Identical objects are equal. `0 === -0`, but they aren't identical.
  // See the [Harmony `egal` proposal](https://wiki.ecmascript.org/doku.php?id=harmony:egal).
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  // `null` or `undefined` only equal to itself (strict comparison).
  if (a == null || b == null) return false;
  // `NaN`s are equivalent, but non-reflexive.
  if (a !== a) return b !== b;
  // Exhaust primitive checks
  var type = typeof a;
  if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
  return deepEq(a, b, aStack, bStack);
}

// Internal recursive comparison function for `_.isEqual`.
function deepEq(a, b, aStack, bStack) {
  // Unwrap any wrapped objects.
  if (a instanceof _$1) a = a._wrapped;
  if (b instanceof _$1) b = b._wrapped;
  // Compare `[[Class]]` names.
  var className = toString.call(a);
  if (className !== toString.call(b)) return false;
  // Work around a bug in IE 10 - Edge 13.
  if (hasStringTagBug && className == '[object Object]' && isDataView$1(a)) {
    if (!isDataView$1(b)) return false;
    className = tagDataView;
  }
  switch (className) {
    // These types are compared by value.
    case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
    case '[object String]':
      // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
      // equivalent to `new String("5")`.
      return '' + a === '' + b;
    case '[object Number]':
      // `NaN`s are equivalent, but non-reflexive.
      // Object(NaN) is equivalent to NaN.
      if (+a !== +a) return +b !== +b;
      // An `egal` comparison is performed for other numeric values.
      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    case '[object Date]':
    case '[object Boolean]':
      // Coerce dates and booleans to numeric primitive values. Dates are compared by their
      // millisecond representations. Note that invalid dates with millisecond representations
      // of `NaN` are not equivalent.
      return +a === +b;
    case '[object Symbol]':
      return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    case '[object ArrayBuffer]':
    case tagDataView:
      // Coerce to typed array so we can fall through.
      return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
  }

  var areArrays = className === '[object Array]';
  if (!areArrays && isTypedArray$1(a)) {
      var byteLength = getByteLength(a);
      if (byteLength !== getByteLength(b)) return false;
      if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;
      areArrays = true;
  }
  if (!areArrays) {
    if (typeof a != 'object' || typeof b != 'object') return false;

    // Objects with different constructors are not equivalent, but `Object`s or `Array`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(isFunction$1(aCtor) && aCtor instanceof aCtor &&
                             isFunction$1(bCtor) && bCtor instanceof bCtor)
                        && ('constructor' in a && 'constructor' in b)) {
      return false;
    }
  }
  // Assume equality for cyclic structures. The algorithm for detecting cyclic
  // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

  // Initializing stack of traversed objects.
  // It's done here since we only need them for objects and arrays comparison.
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    // Linear search. Performance is inversely proportional to the number of
    // unique nested structures.
    if (aStack[length] === a) return bStack[length] === b;
  }

  // Add the first object to the stack of traversed objects.
  aStack.push(a);
  bStack.push(b);

  // Recursively compare objects and arrays.
  if (areArrays) {
    // Compare array lengths to determine if a deep comparison is necessary.
    length = a.length;
    if (length !== b.length) return false;
    // Deep compare the contents, ignoring non-numeric properties.
    while (length--) {
      if (!eq(a[length], b[length], aStack, bStack)) return false;
    }
  } else {
    // Deep compare objects.
    var _keys = keys(a), key;
    length = _keys.length;
    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys(b).length !== length) return false;
    while (length--) {
      // Deep compare each member
      key = _keys[length];
      if (!(has$1(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
    }
  }
  // Remove the first object from the stack of traversed objects.
  aStack.pop();
  bStack.pop();
  return true;
}

// Perform a deep comparison to check if two objects are equal.
function isEqual(a, b) {
  return eq(a, b);
}

// Retrieve all the enumerable property names of an object.
function allKeys(obj) {
  if (!isObject$1(obj)) return [];
  var keys = [];
  for (var key in obj) keys.push(key);
  // Ahem, IE < 9.
  if (hasEnumBug) collectNonEnumProps(obj, keys);
  return keys;
}

// Since the regular `Object.prototype.toString` type tests don't work for
// some types in IE 11, we use a fingerprinting heuristic instead, based
// on the methods. It's not great, but it's the best we got.
// The fingerprint method lists are defined below.
function ie11fingerprint(methods) {
  var length = getLength(methods);
  return function(obj) {
    if (obj == null) return false;
    // `Map`, `WeakMap` and `Set` have no enumerable keys.
    var keys = allKeys(obj);
    if (getLength(keys)) return false;
    for (var i = 0; i < length; i++) {
      if (!isFunction$1(obj[methods[i]])) return false;
    }
    // If we are testing against `WeakMap`, we need to ensure that
    // `obj` doesn't have a `forEach` method in order to distinguish
    // it from a regular `Map`.
    return methods !== weakMapMethods || !isFunction$1(obj[forEachName]);
  };
}

// In the interest of compact minification, we write
// each string in the fingerprints only once.
var forEachName = 'forEach',
    hasName = 'has',
    commonInit = ['clear', 'delete'],
    mapTail = ['get', hasName, 'set'];

// `Map`, `WeakMap` and `Set` each have slightly different
// combinations of the above sublists.
var mapMethods = commonInit.concat(forEachName, mapTail),
    weakMapMethods = commonInit.concat(mapTail),
    setMethods = ['add'].concat(commonInit, forEachName, hasName);

var isMap = isIE11 ? ie11fingerprint(mapMethods) : tagTester('Map');

var isWeakMap = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester('WeakMap');

var isSet = isIE11 ? ie11fingerprint(setMethods) : tagTester('Set');

var isWeakSet = tagTester('WeakSet');

// Retrieve the values of an object's properties.
function values(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var values = Array(length);
  for (var i = 0; i < length; i++) {
    values[i] = obj[_keys[i]];
  }
  return values;
}

// Convert an object into a list of `[key, value]` pairs.
// The opposite of `_.object` with one argument.
function pairs(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var pairs = Array(length);
  for (var i = 0; i < length; i++) {
    pairs[i] = [_keys[i], obj[_keys[i]]];
  }
  return pairs;
}

// Invert the keys and values of an object. The values must be serializable.
function invert(obj) {
  var result = {};
  var _keys = keys(obj);
  for (var i = 0, length = _keys.length; i < length; i++) {
    result[obj[_keys[i]]] = _keys[i];
  }
  return result;
}

// Return a sorted list of the function names available on the object.
function functions(obj) {
  var names = [];
  for (var key in obj) {
    if (isFunction$1(obj[key])) names.push(key);
  }
  return names.sort();
}

// An internal function for creating assigner functions.
function createAssigner(keysFunc, defaults) {
  return function(obj) {
    var length = arguments.length;
    if (defaults) obj = Object(obj);
    if (length < 2 || obj == null) return obj;
    for (var index = 1; index < length; index++) {
      var source = arguments[index],
          keys = keysFunc(source),
          l = keys.length;
      for (var i = 0; i < l; i++) {
        var key = keys[i];
        if (!defaults || obj[key] === void 0) obj[key] = source[key];
      }
    }
    return obj;
  };
}

// Extend a given object with all the properties in passed-in object(s).
var extend = createAssigner(allKeys);

// Assigns a given object with all the own properties in the passed-in
// object(s).
// (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
var extendOwn = createAssigner(keys);

// Fill in a given object with default properties.
var defaults = createAssigner(allKeys, true);

// Create a naked function reference for surrogate-prototype-swapping.
function ctor() {
  return function(){};
}

// An internal function for creating a new object that inherits from another.
function baseCreate(prototype) {
  if (!isObject$1(prototype)) return {};
  if (nativeCreate) return nativeCreate(prototype);
  var Ctor = ctor();
  Ctor.prototype = prototype;
  var result = new Ctor;
  Ctor.prototype = null;
  return result;
}

// Creates an object that inherits from the given prototype object.
// If additional properties are provided then they will be added to the
// created object.
function create(prototype, props) {
  var result = baseCreate(prototype);
  if (props) extendOwn(result, props);
  return result;
}

// Create a (shallow-cloned) duplicate of an object.
function clone(obj) {
  if (!isObject$1(obj)) return obj;
  return isArray(obj) ? obj.slice() : extend({}, obj);
}

// Invokes `interceptor` with the `obj` and then returns `obj`.
// The primary purpose of this method is to "tap into" a method chain, in
// order to perform operations on intermediate results within the chain.
function tap(obj, interceptor) {
  interceptor(obj);
  return obj;
}

// Normalize a (deep) property `path` to array.
// Like `_.iteratee`, this function can be customized.
function toPath$1(path) {
  return isArray(path) ? path : [path];
}
_$1.toPath = toPath$1;

// Internal wrapper for `_.toPath` to enable minification.
// Similar to `cb` for `_.iteratee`.
function toPath(path) {
  return _$1.toPath(path);
}

// Internal function to obtain a nested property in `obj` along `path`.
function deepGet(obj, path) {
  var length = path.length;
  for (var i = 0; i < length; i++) {
    if (obj == null) return void 0;
    obj = obj[path[i]];
  }
  return length ? obj : void 0;
}

// Get the value of the (deep) property on `path` from `object`.
// If any property in `path` does not exist or if the value is
// `undefined`, return `defaultValue` instead.
// The `path` is normalized through `_.toPath`.
function get(object, path, defaultValue) {
  var value = deepGet(object, toPath(path));
  return isUndefined(value) ? defaultValue : value;
}

// Shortcut function for checking if an object has a given property directly on
// itself (in other words, not on a prototype). Unlike the internal `has`
// function, this public version can also traverse nested properties.
function has(obj, path) {
  path = toPath(path);
  var length = path.length;
  for (var i = 0; i < length; i++) {
    var key = path[i];
    if (!has$1(obj, key)) return false;
    obj = obj[key];
  }
  return !!length;
}

// Keep the identity function around for default iteratees.
function identity(value) {
  return value;
}

// Returns a predicate for checking whether an object has a given set of
// `key:value` pairs.
function matcher(attrs) {
  attrs = extendOwn({}, attrs);
  return function(obj) {
    return isMatch(obj, attrs);
  };
}

// Creates a function that, when passed an object, will traverse that object’s
// properties down the given `path`, specified as an array of keys or indices.
function property(path) {
  path = toPath(path);
  return function(obj) {
    return deepGet(obj, path);
  };
}

// Internal function that returns an efficient (for current engines) version
// of the passed-in callback, to be repeatedly applied in other Underscore
// functions.
function optimizeCb(func, context, argCount) {
  if (context === void 0) return func;
  switch (argCount == null ? 3 : argCount) {
    case 1: return function(value) {
      return func.call(context, value);
    };
    // The 2-argument case is omitted because we’re not using it.
    case 3: return function(value, index, collection) {
      return func.call(context, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(context, accumulator, value, index, collection);
    };
  }
  return function() {
    return func.apply(context, arguments);
  };
}

// An internal function to generate callbacks that can be applied to each
// element in a collection, returning the desired result — either `_.identity`,
// an arbitrary callback, a property matcher, or a property accessor.
function baseIteratee(value, context, argCount) {
  if (value == null) return identity;
  if (isFunction$1(value)) return optimizeCb(value, context, argCount);
  if (isObject$1(value) && !isArray(value)) return matcher(value);
  return property(value);
}

// External wrapper for our callback generator. Users may customize
// `_.iteratee` if they want additional predicate/iteratee shorthand styles.
// This abstraction hides the internal-only `argCount` argument.
function iteratee(value, context) {
  return baseIteratee(value, context, Infinity);
}
_$1.iteratee = iteratee;

// The function we call internally to generate a callback. It invokes
// `_.iteratee` if overridden, otherwise `baseIteratee`.
function cb(value, context, argCount) {
  if (_$1.iteratee !== iteratee) return _$1.iteratee(value, context);
  return baseIteratee(value, context, argCount);
}

// Returns the results of applying the `iteratee` to each element of `obj`.
// In contrast to `_.map` it returns an object.
function mapObject$1(obj, iteratee, context) {
  iteratee = cb(iteratee, context);
  var _keys = keys(obj),
      length = _keys.length,
      results = {};
  for (var index = 0; index < length; index++) {
    var currentKey = _keys[index];
    results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
  }
  return results;
}

// Predicate-generating function. Often useful outside of Underscore.
function noop(){}

// Generates a function for a given object that returns a given property.
function propertyOf(obj) {
  if (obj == null) return noop;
  return function(path) {
    return get(obj, path);
  };
}

// Run a function **n** times.
function times(n, iteratee, context) {
  var accum = Array(Math.max(0, n));
  iteratee = optimizeCb(iteratee, context, 1);
  for (var i = 0; i < n; i++) accum[i] = iteratee(i);
  return accum;
}

// Return a random integer between `min` and `max` (inclusive).
function random$1(min, max) {
  if (max == null) {
    max = min;
    min = 0;
  }
  return min + Math.floor(Math.random() * (max - min + 1));
}

// A (possibly faster) way to get the current timestamp as an integer.
var now = Date.now || function() {
  return new Date().getTime();
};

// Internal helper to generate functions for escaping and unescaping strings
// to/from HTML interpolation.
function createEscaper(map) {
  var escaper = function(match) {
    return map[match];
  };
  // Regexes for identifying a key that needs to be escaped.
  var source = '(?:' + keys(map).join('|') + ')';
  var testRegexp = RegExp(source);
  var replaceRegexp = RegExp(source, 'g');
  return function(string) {
    string = string == null ? '' : '' + string;
    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
  };
}

// Internal list of HTML entities for escaping.
var escapeMap = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;'
};

// Function for escaping strings to HTML interpolation.
var escape = createEscaper(escapeMap);

// Internal list of HTML entities for unescaping.
var unescapeMap = invert(escapeMap);

// Function for unescaping strings from HTML interpolation.
var unescape = createEscaper(unescapeMap);

// By default, Underscore uses ERB-style template delimiters. Change the
// following template settings to use alternative delimiters.
var templateSettings = _$1.templateSettings = {
  evaluate: /<%([\s\S]+?)%>/g,
  interpolate: /<%=([\s\S]+?)%>/g,
  escape: /<%-([\s\S]+?)%>/g
};

// When customizing `_.templateSettings`, if you don't want to define an
// interpolation, evaluation or escaping regex, we need one that is
// guaranteed not to match.
var noMatch = /(.)^/;

// Certain characters need to be escaped so that they can be put into a
// string literal.
var escapes = {
  "'": "'",
  '\\': '\\',
  '\r': 'r',
  '\n': 'n',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};

var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

function escapeChar(match) {
  return '\\' + escapes[match];
}

// In order to prevent third-party code injection through
// `_.templateSettings.variable`, we test it against the following regular
// expression. It is intentionally a bit more liberal than just matching valid
// identifiers, but still prevents possible loopholes through defaults or
// destructuring assignment.
var bareIdentifier = /^\s*(\w|\$)+\s*$/;

// JavaScript micro-templating, similar to John Resig's implementation.
// Underscore templating handles arbitrary delimiters, preserves whitespace,
// and correctly escapes quotes within interpolated code.
// NB: `oldSettings` only exists for backwards compatibility.
function template(text, settings, oldSettings) {
  if (!settings && oldSettings) settings = oldSettings;
  settings = defaults({}, settings, _$1.templateSettings);

  // Combine delimiters into one regular expression via alternation.
  var matcher = RegExp([
    (settings.escape || noMatch).source,
    (settings.interpolate || noMatch).source,
    (settings.evaluate || noMatch).source
  ].join('|') + '|$', 'g');

  // Compile the template source, escaping string literals appropriately.
  var index = 0;
  var source = "__p+='";
  text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
    source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
    index = offset + match.length;

    if (escape) {
      source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
    } else if (interpolate) {
      source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
    } else if (evaluate) {
      source += "';\n" + evaluate + "\n__p+='";
    }

    // Adobe VMs need the match returned to produce the correct offset.
    return match;
  });
  source += "';\n";

  var argument = settings.variable;
  if (argument) {
    // Insure against third-party code injection. (CVE-2021-23358)
    if (!bareIdentifier.test(argument)) throw new Error(
      'variable is not a bare identifier: ' + argument
    );
  } else {
    // If a variable is not specified, place data values in local scope.
    source = 'with(obj||{}){\n' + source + '}\n';
    argument = 'obj';
  }

  source = "var __t,__p='',__j=Array.prototype.join," +
    "print=function(){__p+=__j.call(arguments,'');};\n" +
    source + 'return __p;\n';

  var render;
  try {
    render = new Function(argument, '_', source);
  } catch (e) {
    e.source = source;
    throw e;
  }

  var template = function(data) {
    return render.call(this, data, _$1);
  };

  // Provide the compiled source as a convenience for precompilation.
  template.source = 'function(' + argument + '){\n' + source + '}';

  return template;
}

// Traverses the children of `obj` along `path`. If a child is a function, it
// is invoked with its parent as context. Returns the value of the final
// child, or `fallback` if any child is undefined.
function result(obj, path, fallback) {
  path = toPath(path);
  var length = path.length;
  if (!length) {
    return isFunction$1(fallback) ? fallback.call(obj) : fallback;
  }
  for (var i = 0; i < length; i++) {
    var prop = obj == null ? void 0 : obj[path[i]];
    if (prop === void 0) {
      prop = fallback;
      i = length; // Ensure we don't continue iterating.
    }
    obj = isFunction$1(prop) ? prop.call(obj) : prop;
  }
  return obj;
}

// Generate a unique integer id (unique within the entire client session).
// Useful for temporary DOM ids.
var idCounter = 0;
function uniqueId(prefix) {
  var id = ++idCounter + '';
  return prefix ? prefix + id : id;
}

// Start chaining a wrapped Underscore object.
function chain(obj) {
  var instance = _$1(obj);
  instance._chain = true;
  return instance;
}

// Internal function to execute `sourceFunc` bound to `context` with optional
// `args`. Determines whether to execute a function as a constructor or as a
// normal function.
function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
  if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
  var self = baseCreate(sourceFunc.prototype);
  var result = sourceFunc.apply(self, args);
  if (isObject$1(result)) return result;
  return self;
}

// Partially apply a function by creating a version that has had some of its
// arguments pre-filled, without changing its dynamic `this` context. `_` acts
// as a placeholder by default, allowing any combination of arguments to be
// pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
var partial = restArguments(function(func, boundArgs) {
  var placeholder = partial.placeholder;
  var bound = function() {
    var position = 0, length = boundArgs.length;
    var args = Array(length);
    for (var i = 0; i < length; i++) {
      args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
    }
    while (position < arguments.length) args.push(arguments[position++]);
    return executeBound(func, bound, this, this, args);
  };
  return bound;
});

partial.placeholder = _$1;

// Create a function bound to a given object (assigning `this`, and arguments,
// optionally).
var bind = restArguments(function(func, context, args) {
  if (!isFunction$1(func)) throw new TypeError('Bind must be called on a function');
  var bound = restArguments(function(callArgs) {
    return executeBound(func, bound, context, this, args.concat(callArgs));
  });
  return bound;
});

// Internal helper for collection methods to determine whether a collection
// should be iterated as an array or as an object.
// Related: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
// Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
var isArrayLike = createSizePropertyCheck(getLength);

// Internal implementation of a recursive `flatten` function.
function flatten$1(input, depth, strict, output) {
  output = output || [];
  if (!depth && depth !== 0) {
    depth = Infinity;
  } else if (depth <= 0) {
    return output.concat(input);
  }
  var idx = output.length;
  for (var i = 0, length = getLength(input); i < length; i++) {
    var value = input[i];
    if (isArrayLike(value) && (isArray(value) || isArguments$1(value))) {
      // Flatten current level of array or arguments object.
      if (depth > 1) {
        flatten$1(value, depth - 1, strict, output);
        idx = output.length;
      } else {
        var j = 0, len = value.length;
        while (j < len) output[idx++] = value[j++];
      }
    } else if (!strict) {
      output[idx++] = value;
    }
  }
  return output;
}

// Bind a number of an object's methods to that object. Remaining arguments
// are the method names to be bound. Useful for ensuring that all callbacks
// defined on an object belong to it.
var bindAll = restArguments(function(obj, keys) {
  keys = flatten$1(keys, false, false);
  var index = keys.length;
  if (index < 1) throw new Error('bindAll must be passed function names');
  while (index--) {
    var key = keys[index];
    obj[key] = bind(obj[key], obj);
  }
  return obj;
});

// Memoize an expensive function by storing its results.
function memoize(func, hasher) {
  var memoize = function(key) {
    var cache = memoize.cache;
    var address = '' + (hasher ? hasher.apply(this, arguments) : key);
    if (!has$1(cache, address)) cache[address] = func.apply(this, arguments);
    return cache[address];
  };
  memoize.cache = {};
  return memoize;
}

// Delays a function for the given number of milliseconds, and then calls
// it with the arguments supplied.
var delay = restArguments(function(func, wait, args) {
  return setTimeout(function() {
    return func.apply(null, args);
  }, wait);
});

// Defers a function, scheduling it to run after the current call stack has
// cleared.
var defer = partial(delay, _$1, 1);

// Returns a function, that, when invoked, will only be triggered at most once
// during a given window of time. Normally, the throttled function will run
// as much as it can, without ever going more than once per `wait` duration;
// but if you'd like to disable the execution on the leading edge, pass
// `{leading: false}`. To disable execution on the trailing edge, ditto.
function throttle(func, wait, options) {
  var timeout, context, args, result;
  var previous = 0;
  if (!options) options = {};

  var later = function() {
    previous = options.leading === false ? 0 : now();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };

  var throttled = function() {
    var _now = now();
    if (!previous && options.leading === false) previous = _now;
    var remaining = wait - (_now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = _now;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };

  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };

  return throttled;
}

// When a sequence of calls of the returned function ends, the argument
// function is triggered. The end of a sequence is defined by the `wait`
// parameter. If `immediate` is passed, the argument function will be
// triggered at the beginning of the sequence instead of at the end.
function debounce(func, wait, immediate) {
  var timeout, previous, args, result, context;

  var later = function() {
    var passed = now() - previous;
    if (wait > passed) {
      timeout = setTimeout(later, wait - passed);
    } else {
      timeout = null;
      if (!immediate) result = func.apply(context, args);
      // This check is needed because `func` can recursively invoke `debounced`.
      if (!timeout) args = context = null;
    }
  };

  var debounced = restArguments(function(_args) {
    context = this;
    args = _args;
    previous = now();
    if (!timeout) {
      timeout = setTimeout(later, wait);
      if (immediate) result = func.apply(context, args);
    }
    return result;
  });

  debounced.cancel = function() {
    clearTimeout(timeout);
    timeout = args = context = null;
  };

  return debounced;
}

// Returns the first function passed as an argument to the second,
// allowing you to adjust arguments, run code before and after, and
// conditionally execute the original function.
function wrap(func, wrapper) {
  return partial(wrapper, func);
}

// Returns a negated version of the passed-in predicate.
function negate(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}

// Returns a function that is the composition of a list of functions, each
// consuming the return value of the function that follows.
function compose() {
  var args = arguments;
  var start = args.length - 1;
  return function() {
    var i = start;
    var result = args[start].apply(this, arguments);
    while (i--) result = args[i].call(this, result);
    return result;
  };
}

// Returns a function that will only be executed on and after the Nth call.
function after(times, func) {
  return function() {
    if (--times < 1) {
      return func.apply(this, arguments);
    }
  };
}

// Returns a function that will only be executed up to (but not including) the
// Nth call.
function before(times, func) {
  var memo;
  return function() {
    if (--times > 0) {
      memo = func.apply(this, arguments);
    }
    if (times <= 1) func = null;
    return memo;
  };
}

// Returns a function that will be executed at most one time, no matter how
// often you call it. Useful for lazy initialization.
var once = partial(before, 2);

// Returns the first key on an object that passes a truth test.
function findKey(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = keys(obj), key;
  for (var i = 0, length = _keys.length; i < length; i++) {
    key = _keys[i];
    if (predicate(obj[key], key, obj)) return key;
  }
}

// Internal function to generate `_.findIndex` and `_.findLastIndex`.
function createPredicateIndexFinder(dir) {
  return function(array, predicate, context) {
    predicate = cb(predicate, context);
    var length = getLength(array);
    var index = dir > 0 ? 0 : length - 1;
    for (; index >= 0 && index < length; index += dir) {
      if (predicate(array[index], index, array)) return index;
    }
    return -1;
  };
}

// Returns the first index on an array-like that passes a truth test.
var findIndex = createPredicateIndexFinder(1);

// Returns the last index on an array-like that passes a truth test.
var findLastIndex = createPredicateIndexFinder(-1);

// Use a comparator function to figure out the smallest index at which
// an object should be inserted so as to maintain order. Uses binary search.
function sortedIndex(array, obj, iteratee, context) {
  iteratee = cb(iteratee, context, 1);
  var value = iteratee(obj);
  var low = 0, high = getLength(array);
  while (low < high) {
    var mid = Math.floor((low + high) / 2);
    if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
  }
  return low;
}

// Internal function to generate the `_.indexOf` and `_.lastIndexOf` functions.
function createIndexFinder(dir, predicateFind, sortedIndex) {
  return function(array, item, idx) {
    var i = 0, length = getLength(array);
    if (typeof idx == 'number') {
      if (dir > 0) {
        i = idx >= 0 ? idx : Math.max(idx + length, i);
      } else {
        length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
      }
    } else if (sortedIndex && idx && length) {
      idx = sortedIndex(array, item);
      return array[idx] === item ? idx : -1;
    }
    if (item !== item) {
      idx = predicateFind(slice.call(array, i, length), isNaN$1);
      return idx >= 0 ? idx + i : -1;
    }
    for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
      if (array[idx] === item) return idx;
    }
    return -1;
  };
}

// Return the position of the first occurrence of an item in an array,
// or -1 if the item is not included in the array.
// If the array is large and already in sort order, pass `true`
// for **isSorted** to use binary search.
var indexOf = createIndexFinder(1, findIndex, sortedIndex);

// Return the position of the last occurrence of an item in an array,
// or -1 if the item is not included in the array.
var lastIndexOf = createIndexFinder(-1, findLastIndex);

// Return the first value which passes a truth test.
function find(obj, predicate, context) {
  var keyFinder = isArrayLike(obj) ? findIndex : findKey;
  var key = keyFinder(obj, predicate, context);
  if (key !== void 0 && key !== -1) return obj[key];
}

// Convenience version of a common use case of `_.find`: getting the first
// object containing specific `key:value` pairs.
function findWhere(obj, attrs) {
  return find(obj, matcher(attrs));
}

// The cornerstone for collection functions, an `each`
// implementation, aka `forEach`.
// Handles raw objects in addition to array-likes. Treats all
// sparse array-likes as if they were dense.
function each(obj, iteratee, context) {
  iteratee = optimizeCb(iteratee, context);
  var i, length;
  if (isArrayLike(obj)) {
    for (i = 0, length = obj.length; i < length; i++) {
      iteratee(obj[i], i, obj);
    }
  } else {
    var _keys = keys(obj);
    for (i = 0, length = _keys.length; i < length; i++) {
      iteratee(obj[_keys[i]], _keys[i], obj);
    }
  }
  return obj;
}

// Return the results of applying the iteratee to each element.
function map(obj, iteratee, context) {
  iteratee = cb(iteratee, context);
  var _keys = !isArrayLike(obj) && keys(obj),
      length = (_keys || obj).length,
      results = Array(length);
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    results[index] = iteratee(obj[currentKey], currentKey, obj);
  }
  return results;
}

// Internal helper to create a reducing function, iterating left or right.
function createReduce(dir) {
  // Wrap code that reassigns argument variables in a separate function than
  // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
  var reducer = function(obj, iteratee, memo, initial) {
    var _keys = !isArrayLike(obj) && keys(obj),
        length = (_keys || obj).length,
        index = dir > 0 ? 0 : length - 1;
    if (!initial) {
      memo = obj[_keys ? _keys[index] : index];
      index += dir;
    }
    for (; index >= 0 && index < length; index += dir) {
      var currentKey = _keys ? _keys[index] : index;
      memo = iteratee(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };

  return function(obj, iteratee, memo, context) {
    var initial = arguments.length >= 3;
    return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
  };
}

// **Reduce** builds up a single result from a list of values, aka `inject`,
// or `foldl`.
var reduce = createReduce(1);

// The right-associative version of reduce, also known as `foldr`.
var reduceRight = createReduce(-1);

// Return all the elements that pass a truth test.
function filter(obj, predicate, context) {
  var results = [];
  predicate = cb(predicate, context);
  each(obj, function(value, index, list) {
    if (predicate(value, index, list)) results.push(value);
  });
  return results;
}

// Return all the elements for which a truth test fails.
function reject(obj, predicate, context) {
  return filter(obj, negate(cb(predicate)), context);
}

// Determine whether all of the elements pass a truth test.
function every(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike(obj) && keys(obj),
      length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (!predicate(obj[currentKey], currentKey, obj)) return false;
  }
  return true;
}

// Determine if at least one element in the object passes a truth test.
function some(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike(obj) && keys(obj),
      length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (predicate(obj[currentKey], currentKey, obj)) return true;
  }
  return false;
}

// Determine if the array or object contains a given item (using `===`).
function contains(obj, item, fromIndex, guard) {
  if (!isArrayLike(obj)) obj = values(obj);
  if (typeof fromIndex != 'number' || guard) fromIndex = 0;
  return indexOf(obj, item, fromIndex) >= 0;
}

// Invoke a method (with arguments) on every item in a collection.
var invoke = restArguments(function(obj, path, args) {
  var contextPath, func;
  if (isFunction$1(path)) {
    func = path;
  } else {
    path = toPath(path);
    contextPath = path.slice(0, -1);
    path = path[path.length - 1];
  }
  return map(obj, function(context) {
    var method = func;
    if (!method) {
      if (contextPath && contextPath.length) {
        context = deepGet(context, contextPath);
      }
      if (context == null) return void 0;
      method = context[path];
    }
    return method == null ? method : method.apply(context, args);
  });
});

// Convenience version of a common use case of `_.map`: fetching a property.
function pluck$1(obj, key) {
  return map(obj, property(key));
}

// Convenience version of a common use case of `_.filter`: selecting only
// objects containing specific `key:value` pairs.
function where(obj, attrs) {
  return filter(obj, matcher(attrs));
}

// Return the maximum element (or element-based computation).
function max(obj, iteratee, context) {
  var result = -Infinity, lastComputed = -Infinity,
      value, computed;
  if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null)) {
    obj = isArrayLike(obj) ? obj : values(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value > result) {
        result = value;
      }
    }
  } else {
    iteratee = cb(iteratee, context);
    each(obj, function(v, index, list) {
      computed = iteratee(v, index, list);
      if (computed > lastComputed || (computed === -Infinity && result === -Infinity)) {
        result = v;
        lastComputed = computed;
      }
    });
  }
  return result;
}

// Return the minimum element (or element-based computation).
function min(obj, iteratee, context) {
  var result = Infinity, lastComputed = Infinity,
      value, computed;
  if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null)) {
    obj = isArrayLike(obj) ? obj : values(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value < result) {
        result = value;
      }
    }
  } else {
    iteratee = cb(iteratee, context);
    each(obj, function(v, index, list) {
      computed = iteratee(v, index, list);
      if (computed < lastComputed || (computed === Infinity && result === Infinity)) {
        result = v;
        lastComputed = computed;
      }
    });
  }
  return result;
}

// Safely create a real, live array from anything iterable.
var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
function toArray(obj) {
  if (!obj) return [];
  if (isArray(obj)) return slice.call(obj);
  if (isString(obj)) {
    // Keep surrogate pair characters together.
    return obj.match(reStrSymbol);
  }
  if (isArrayLike(obj)) return map(obj, identity);
  return values(obj);
}

// Sample **n** random values from a collection using the modern version of the
// [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
// If **n** is not specified, returns a single random element.
// The internal `guard` argument allows it to work with `_.map`.
function sample(obj, n, guard) {
  if (n == null || guard) {
    if (!isArrayLike(obj)) obj = values(obj);
    return obj[random$1(obj.length - 1)];
  }
  var sample = toArray(obj);
  var length = getLength(sample);
  n = Math.max(Math.min(n, length), 0);
  var last = length - 1;
  for (var index = 0; index < n; index++) {
    var rand = random$1(index, last);
    var temp = sample[index];
    sample[index] = sample[rand];
    sample[rand] = temp;
  }
  return sample.slice(0, n);
}

// Shuffle a collection.
function shuffle$1(obj) {
  return sample(obj, Infinity);
}

// Sort the object's values by a criterion produced by an iteratee.
function sortBy(obj, iteratee, context) {
  var index = 0;
  iteratee = cb(iteratee, context);
  return pluck$1(map(obj, function(value, key, list) {
    return {
      value: value,
      index: index++,
      criteria: iteratee(value, key, list)
    };
  }).sort(function(left, right) {
    var a = left.criteria;
    var b = right.criteria;
    if (a !== b) {
      if (a > b || a === void 0) return 1;
      if (a < b || b === void 0) return -1;
    }
    return left.index - right.index;
  }), 'value');
}

// An internal function used for aggregate "group by" operations.
function group(behavior, partition) {
  return function(obj, iteratee, context) {
    var result = partition ? [[], []] : {};
    iteratee = cb(iteratee, context);
    each(obj, function(value, index) {
      var key = iteratee(value, index, obj);
      behavior(result, value, key);
    });
    return result;
  };
}

// Groups the object's values by a criterion. Pass either a string attribute
// to group by, or a function that returns the criterion.
var groupBy = group(function(result, value, key) {
  if (has$1(result, key)) result[key].push(value); else result[key] = [value];
});

// Indexes the object's values by a criterion, similar to `_.groupBy`, but for
// when you know that your index values will be unique.
var indexBy = group(function(result, value, key) {
  result[key] = value;
});

// Counts instances of an object that group by a certain criterion. Pass
// either a string attribute to count by, or a function that returns the
// criterion.
var countBy = group(function(result, value, key) {
  if (has$1(result, key)) result[key]++; else result[key] = 1;
});

// Split a collection into two arrays: one whose elements all pass the given
// truth test, and one whose elements all do not pass the truth test.
var partition = group(function(result, value, pass) {
  result[pass ? 0 : 1].push(value);
}, true);

// Return the number of elements in a collection.
function size(obj) {
  if (obj == null) return 0;
  return isArrayLike(obj) ? obj.length : keys(obj).length;
}

// Internal `_.pick` helper function to determine whether `key` is an enumerable
// property name of `obj`.
function keyInObj(value, key, obj) {
  return key in obj;
}

// Return a copy of the object only containing the allowed properties.
var pick = restArguments(function(obj, keys) {
  var result = {}, iteratee = keys[0];
  if (obj == null) return result;
  if (isFunction$1(iteratee)) {
    if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
    keys = allKeys(obj);
  } else {
    iteratee = keyInObj;
    keys = flatten$1(keys, false, false);
    obj = Object(obj);
  }
  for (var i = 0, length = keys.length; i < length; i++) {
    var key = keys[i];
    var value = obj[key];
    if (iteratee(value, key, obj)) result[key] = value;
  }
  return result;
});

// Return a copy of the object without the disallowed properties.
var omit = restArguments(function(obj, keys) {
  var iteratee = keys[0], context;
  if (isFunction$1(iteratee)) {
    iteratee = negate(iteratee);
    if (keys.length > 1) context = keys[1];
  } else {
    keys = map(flatten$1(keys, false, false), String);
    iteratee = function(value, key) {
      return !contains(keys, key);
    };
  }
  return pick(obj, iteratee, context);
});

// Returns everything but the last entry of the array. Especially useful on
// the arguments object. Passing **n** will return all the values in
// the array, excluding the last N.
function initial(array, n, guard) {
  return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
}

// Get the first element of an array. Passing **n** will return the first N
// values in the array. The **guard** check allows it to work with `_.map`.
function first(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[0];
  return initial(array, array.length - n);
}

// Returns everything but the first entry of the `array`. Especially useful on
// the `arguments` object. Passing an **n** will return the rest N values in the
// `array`.
function rest(array, n, guard) {
  return slice.call(array, n == null || guard ? 1 : n);
}

// Get the last element of an array. Passing **n** will return the last N
// values in the array.
function last(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[array.length - 1];
  return rest(array, Math.max(0, array.length - n));
}

// Trim out all falsy values from an array.
function compact(array) {
  return filter(array, Boolean);
}

// Flatten out an array, either recursively (by default), or up to `depth`.
// Passing `true` or `false` as `depth` means `1` or `Infinity`, respectively.
function flatten(array, depth) {
  return flatten$1(array, depth, false);
}

// Take the difference between one array and a number of other arrays.
// Only the elements present in just the first array will remain.
var difference = restArguments(function(array, rest) {
  rest = flatten$1(rest, true, true);
  return filter(array, function(value){
    return !contains(rest, value);
  });
});

// Return a version of the array that does not contain the specified value(s).
var without = restArguments(function(array, otherArrays) {
  return difference(array, otherArrays);
});

// Produce a duplicate-free version of the array. If the array has already
// been sorted, you have the option of using a faster algorithm.
// The faster algorithm will not work with an iteratee if the iteratee
// is not a one-to-one function, so providing an iteratee will disable
// the faster algorithm.
function uniq(array, isSorted, iteratee, context) {
  if (!isBoolean(isSorted)) {
    context = iteratee;
    iteratee = isSorted;
    isSorted = false;
  }
  if (iteratee != null) iteratee = cb(iteratee, context);
  var result = [];
  var seen = [];
  for (var i = 0, length = getLength(array); i < length; i++) {
    var value = array[i],
        computed = iteratee ? iteratee(value, i, array) : value;
    if (isSorted && !iteratee) {
      if (!i || seen !== computed) result.push(value);
      seen = computed;
    } else if (iteratee) {
      if (!contains(seen, computed)) {
        seen.push(computed);
        result.push(value);
      }
    } else if (!contains(result, value)) {
      result.push(value);
    }
  }
  return result;
}

// Produce an array that contains the union: each distinct element from all of
// the passed-in arrays.
var union$1 = restArguments(function(arrays) {
  return uniq(flatten$1(arrays, true, true));
});

// Produce an array that contains every item shared between all the
// passed-in arrays.
function intersection(array) {
  var result = [];
  var argsLength = arguments.length;
  for (var i = 0, length = getLength(array); i < length; i++) {
    var item = array[i];
    if (contains(result, item)) continue;
    var j;
    for (j = 1; j < argsLength; j++) {
      if (!contains(arguments[j], item)) break;
    }
    if (j === argsLength) result.push(item);
  }
  return result;
}

// Complement of zip. Unzip accepts an array of arrays and groups
// each array's elements on shared indices.
function unzip(array) {
  var length = (array && max(array, getLength).length) || 0;
  var result = Array(length);

  for (var index = 0; index < length; index++) {
    result[index] = pluck$1(array, index);
  }
  return result;
}

// Zip together multiple lists into a single array -- elements that share
// an index go together.
var zip = restArguments(unzip);

// Converts lists into objects. Pass either a single array of `[key, value]`
// pairs, or two parallel arrays of the same length -- one of keys, and one of
// the corresponding values. Passing by pairs is the reverse of `_.pairs`.
function object$1(list, values) {
  var result = {};
  for (var i = 0, length = getLength(list); i < length; i++) {
    if (values) {
      result[list[i]] = values[i];
    } else {
      result[list[i][0]] = list[i][1];
    }
  }
  return result;
}

// Generate an integer Array containing an arithmetic progression. A port of
// the native Python `range()` function. See
// [the Python documentation](https://docs.python.org/library/functions.html#range).
function range(start, stop, step) {
  if (stop == null) {
    stop = start || 0;
    start = 0;
  }
  if (!step) {
    step = stop < start ? -1 : 1;
  }

  var length = Math.max(Math.ceil((stop - start) / step), 0);
  var range = Array(length);

  for (var idx = 0; idx < length; idx++, start += step) {
    range[idx] = start;
  }

  return range;
}

// Chunk a single array into multiple arrays, each containing `count` or fewer
// items.
function chunk(array, count) {
  if (count == null || count < 1) return [];
  var result = [];
  var i = 0, length = array.length;
  while (i < length) {
    result.push(slice.call(array, i, i += count));
  }
  return result;
}

// Helper function to continue chaining intermediate results.
function chainResult(instance, obj) {
  return instance._chain ? _$1(obj).chain() : obj;
}

// Add your own custom functions to the Underscore object.
function mixin(obj) {
  each(functions(obj), function(name) {
    var func = _$1[name] = obj[name];
    _$1.prototype[name] = function() {
      var args = [this._wrapped];
      push.apply(args, arguments);
      return chainResult(this, func.apply(_$1, args));
    };
  });
  return _$1;
}

// Add all mutator `Array` functions to the wrapper.
each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
  var method = ArrayProto[name];
  _$1.prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null) {
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) {
        delete obj[0];
      }
    }
    return chainResult(this, obj);
  };
});

// Add all accessor `Array` functions to the wrapper.
each(['concat', 'join', 'slice'], function(name) {
  var method = ArrayProto[name];
  _$1.prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null) obj = method.apply(obj, arguments);
    return chainResult(this, obj);
  };
});

// Named Exports

var allExports = /*#__PURE__*/Object.freeze({
    __proto__: null,
    VERSION: VERSION,
    restArguments: restArguments,
    isObject: isObject$1,
    isNull: isNull,
    isUndefined: isUndefined,
    isBoolean: isBoolean,
    isElement: isElement,
    isString: isString,
    isNumber: isNumber,
    isDate: isDate,
    isRegExp: isRegExp,
    isError: isError,
    isSymbol: isSymbol,
    isArrayBuffer: isArrayBuffer,
    isDataView: isDataView$1,
    isArray: isArray,
    isFunction: isFunction$1,
    isArguments: isArguments$1,
    isFinite: isFinite$1,
    isNaN: isNaN$1,
    isTypedArray: isTypedArray$1,
    isEmpty: isEmpty,
    isMatch: isMatch,
    isEqual: isEqual,
    isMap: isMap,
    isWeakMap: isWeakMap,
    isSet: isSet,
    isWeakSet: isWeakSet,
    keys: keys,
    allKeys: allKeys,
    values: values,
    pairs: pairs,
    invert: invert,
    functions: functions,
    methods: functions,
    extend: extend,
    extendOwn: extendOwn,
    assign: extendOwn,
    defaults: defaults,
    create: create,
    clone: clone,
    tap: tap,
    get: get,
    has: has,
    mapObject: mapObject$1,
    identity: identity,
    constant: constant$1,
    noop: noop,
    toPath: toPath$1,
    property: property,
    propertyOf: propertyOf,
    matcher: matcher,
    matches: matcher,
    times: times,
    random: random$1,
    now: now,
    escape: escape,
    unescape: unescape,
    templateSettings: templateSettings,
    template: template,
    result: result,
    uniqueId: uniqueId,
    chain: chain,
    iteratee: iteratee,
    partial: partial,
    bind: bind,
    bindAll: bindAll,
    memoize: memoize,
    delay: delay,
    defer: defer,
    throttle: throttle,
    debounce: debounce,
    wrap: wrap,
    negate: negate,
    compose: compose,
    after: after,
    before: before,
    once: once,
    findKey: findKey,
    findIndex: findIndex,
    findLastIndex: findLastIndex,
    sortedIndex: sortedIndex,
    indexOf: indexOf,
    lastIndexOf: lastIndexOf,
    find: find,
    detect: find,
    findWhere: findWhere,
    each: each,
    forEach: each,
    map: map,
    collect: map,
    reduce: reduce,
    foldl: reduce,
    inject: reduce,
    reduceRight: reduceRight,
    foldr: reduceRight,
    filter: filter,
    select: filter,
    reject: reject,
    every: every,
    all: every,
    some: some,
    any: some,
    contains: contains,
    includes: contains,
    include: contains,
    invoke: invoke,
    pluck: pluck$1,
    where: where,
    max: max,
    min: min,
    shuffle: shuffle$1,
    sample: sample,
    sortBy: sortBy,
    groupBy: groupBy,
    indexBy: indexBy,
    countBy: countBy,
    partition: partition,
    toArray: toArray,
    size: size,
    pick: pick,
    omit: omit,
    first: first,
    head: first,
    take: first,
    initial: initial,
    last: last,
    rest: rest,
    tail: rest,
    drop: rest,
    compact: compact,
    flatten: flatten,
    without: without,
    uniq: uniq,
    unique: uniq,
    union: union$1,
    intersection: intersection,
    difference: difference,
    unzip: unzip,
    transpose: unzip,
    zip: zip,
    object: object$1,
    range: range,
    chunk: chunk,
    mixin: mixin,
    'default': _$1
});

// Default Export

// Add all of the Underscore functions to the wrapper object.
var _ = mixin(allExports);
// Legacy Node.js API.
_._ = _;

function getMatrixSize(matrix) {
  const matrixSize = [1, 1];

  // We need to find the widest row and tallest column to get the correct
  // matrix size.
  _(matrix).each((matrixRow, row) => {
    let rowWidth = 0;
    _(matrixRow).each((matrixCol, col) => {
      if (matrixCol != null && matrixCol.toString().length) {
        rowWidth = col + 1;
      }
    });

    // Matrix width:
    matrixSize[1] = Math.max(matrixSize[1], rowWidth);

    // Matrix height:
    if (rowWidth > 0) {
      matrixSize[0] = Math.max(matrixSize[0], row + 1);
    }
  });
  return matrixSize;
}

/**
 *  Get the character used for separating decimals.
 */
const getDecimalSeparator = locale => {
  var _match$;
  switch (locale) {
    // TODO(somewhatabstract): Remove this when Chrome supports the `ka`
    // locale properly.
    // https://github.com/formatjs/formatjs/issues/1526#issuecomment-559891201
    //
    // Supported locales in Chrome:
    // https://source.chromium.org/chromium/chromium/src/+/master:third_party/icu/scripts/chrome_ui_languages.list
    case "ka":
      return ",";
    default:
      const numberWithDecimalSeparator = 1.1;
      // TODO(FEI-3647): Update to use .formatToParts() once we no longer have to
      // support Safari 12.
      const match = new Intl.NumberFormat(locale).format(numberWithDecimalSeparator)
      // 0x661 is ARABIC-INDIC DIGIT ONE
      // 0x6F1 is EXTENDED ARABIC-INDIC DIGIT ONE
      .match(/[^\d\u0661\u06F1]/);
      return (_match$ = match == null ? void 0 : match[0]) != null ? _match$ : ".";
  }
};

/**
 * APPROXIMATE equality on numbers and primitives.
 */
function approximateEqual(x, y) {
  if (typeof x === "number" && typeof y === "number") {
    return Math.abs(x - y) < 1e-9;
  }
  return x === y;
}

/**
 * Deep APPROXIMATE equality on primitives, numbers, arrays, and objects.
 * Recursive.
 */
function approximateDeepEqual(x, y) {
  if (Array.isArray(x) && Array.isArray(y)) {
    if (x.length !== y.length) {
      return false;
    }
    for (let i = 0; i < x.length; i++) {
      if (!approximateDeepEqual(x[i], y[i])) {
        return false;
      }
    }
    return true;
  }
  if (Array.isArray(x) || Array.isArray(y)) {
    return false;
  }
  if (typeof x === "function" && typeof y === "function") {
    return approximateEqual(x, y);
  }
  if (typeof x === "function" || typeof y === "function") {
    return false;
  }
  if (typeof x === "object" && typeof y === "object" && !!x && !!y) {
    return x === y || _.all(x, function (v, k) {
      // @ts-expect-error - TS2536 - Type 'CollectionKey<T>' cannot be used to index type 'T'.
      return approximateDeepEqual(y[k], v);
    }) && _.all(y, function (v, k) {
      // @ts-expect-error - TS2536 - Type 'CollectionKey<T>' cannot be used to index type 'T'.
      return approximateDeepEqual(x[k], v);
    });
  }
  if (typeof x === "object" && !!x || typeof y === "object" && !!y) {
    return false;
  }
  return approximateEqual(x, y);
}

/**
 * Add a widget placeholder using the widget ID.
 * ex. addWidget("radio 1") => "[[☃ radio 1]]"
 *
 * @param {string} id
 * @returns {string}
 */
function addWidget(id) {
  return `[[☃ ${id}]]`;
}

/**
 * Regex for widget placeholders in a string.
 *
 * First capture group is the widget ID (ex. 'radio 1')
 * Second capture group is the widget type (ex. "radio)
 * exec return will look like: ['[[☃ radio 1]]', 'radio 1', 'radio']
 */
function getWidgetRegex() {
  return /\[\[☃ ([A-Za-z0-9- ]+)\]\]/g;
}

/**
 * Extract all widget IDs, which includes the widget type and instance number.
 * example output: ['radio 1', 'categorizer 1', 'categorizor 2']
 *
 * Content should contain Perseus widget placeholders,
 * which look like: '[[☃ radio 1]]'.
 *
 * @param {string} content
 * @returns {ReadonlyArray<string>} widgetIds
 */
function getWidgetIdsFromContent(content) {
  const widgets = [];
  const localWidgetRegex = getWidgetRegex();
  let match = localWidgetRegex.exec(content);
  while (match !== null) {
    widgets.push(match[1]);
    match = localWidgetRegex.exec(content);
  }
  return widgets;
}

/**
 * Get a list of widget IDs from content,
 * but only for specific widget types
 *
 * @param {string} type the type of widget (ie "radio")
 * @param {string} content the string to parse
 * @param {PerseusWidgetsMap} widgetMap widget ID to widget map
 * @returns {ReadonlyArray<string>} the widget type (ie "radio")
 */
function getWidgetIdsFromContentByType(type, content, widgetMap) {
  const rv = [];
  const widgetIdsInContent = getWidgetIdsFromContent(content);
  widgetIdsInContent.forEach(widgetId => {
    const widget = widgetMap[widgetId];
    if ((widget == null ? void 0 : widget.type) === type) {
      rv.push(widgetId);
    }
  });
  return rv;
}

// TODO(benchristel): in the future, we may want to make deepClone work for
// Record<string, Cloneable> as well. Currently, it only does arrays.

function deepClone(obj) {
  if (Array.isArray(obj)) {
    return obj.map(deepClone);
  }
  return obj;
}

const MOVABLES = {
  PLOT: "PLOT",
  PARABOLA: "PARABOLA",
  SINUSOID: "SINUSOID"
};

// TODO(charlie): These really need to go into a utility file as they're being
// used by both interactive-graph and now grapher.
function canonicalSineCoefficients(coeffs) {
  // For a curve of the form f(x) = a * Sin(b * x - c) + d,
  // this function ensures that a, b > 0, and c is its
  // smallest possible positive value.
  let amplitude = coeffs[0];
  let angularFrequency = coeffs[1];
  let phase = coeffs[2];
  const verticalOffset = coeffs[3];

  // Guarantee a > 0
  if (amplitude < 0) {
    amplitude *= -1;
    angularFrequency *= -1;
    phase *= -1;
  }
  const period = 2 * Math.PI;
  // Guarantee b > 0
  if (angularFrequency < 0) {
    angularFrequency *= -1;
    phase *= -1;
    phase += period / 2;
  }

  // Guarantee c is smallest possible positive value
  while (phase > 0) {
    phase -= period;
  }
  while (phase < 0) {
    phase += period;
  }
  return [amplitude, angularFrequency, phase, verticalOffset];
}
function canonicalTangentCoefficients(coeffs) {
  // For a curve of the form f(x) = a * Tan(b * x - c) + d,
  // this function ensures that a, b > 0, and c is its
  // smallest possible positive value.
  let amplitude = coeffs[0];
  let angularFrequency = coeffs[1];
  let phase = coeffs[2];
  const verticalOffset = coeffs[3];

  // Guarantee a > 0
  if (amplitude < 0) {
    amplitude *= -1;
    angularFrequency *= -1;
    phase *= -1;
  }
  const period = Math.PI;
  // Guarantee b > 0
  if (angularFrequency < 0) {
    angularFrequency *= -1;
    phase *= -1;
    phase += period / 2;
  }

  // Guarantee c is smallest possible positive value
  while (phase > 0) {
    phase -= period;
  }
  while (phase < 0) {
    phase += period;
  }
  return [amplitude, angularFrequency, phase, verticalOffset];
}
const PlotDefaults = {
  areEqual: function (coeffs1, coeffs2) {
    return approximateDeepEqual(coeffs1, coeffs2);
  },
  movable: MOVABLES.PLOT,
  getPropsForCoeffs: function (coeffs) {
    return {
      // @ts-expect-error - TS2339 - Property 'getFunctionForCoeffs' does not exist on type '{ readonly areEqual: (coeffs1: any, coeffs2: any) => boolean; readonly Movable: any; readonly getPropsForCoeffs: (coeffs: any) => any; }'.
      fn: _.partial(this.getFunctionForCoeffs, coeffs)
    };
  }
};
const Linear = _.extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/67aaf581e6d9ef9038c10558a1f70ac21c11c9f8.png",
  defaultCoords: [[0.25, 0.75], [0.75, 0.75]],
  getCoefficients: function (coords) {
    const p1 = coords[0];
    const p2 = coords[1];
    const denom = p2[0] - p1[0];
    const num = p2[1] - p1[1];
    if (denom === 0) {
      return;
    }
    const m = num / denom;
    const b = p2[1] - m * p2[0];
    return [m, b];
  },
  getFunctionForCoeffs: function (coeffs, x) {
    const m = coeffs[0];
    const b = coeffs[1];
    return m * x + b;
  },
  getEquationString: function (coords) {
    const coeffs = this.getCoefficients(coords);
    const m = coeffs[0];
    const b = coeffs[1];
    return "y = " + m.toFixed(3) + "x + " + b.toFixed(3);
  }
});
const Quadratic = _.extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/e23d36e6fc29ee37174e92c9daba2a66677128ab.png",
  defaultCoords: [[0.5, 0.5], [0.75, 0.75]],
  movable: MOVABLES.PARABOLA,
  getCoefficients: function (coords) {
    const p1 = coords[0];
    const p2 = coords[1];

    // Parabola with vertex (h, k) has form: y = a * (h - k)^2 + k
    const h = p1[0];
    const k = p1[1];

    // Use these to calculate familiar a, b, c
    const a = (p2[1] - k) / ((p2[0] - h) * (p2[0] - h));
    const b = -2 * h * a;
    const c = a * h * h + k;
    return [a, b, c];
  },
  getFunctionForCoeffs: function (coeffs, x) {
    const a = coeffs[0];
    const b = coeffs[1];
    const c = coeffs[2];
    return (a * x + b) * x + c;
  },
  getPropsForCoeffs: function (coeffs) {
    return {
      a: coeffs[0],
      b: coeffs[1],
      c: coeffs[2]
    };
  },
  getEquationString: function (coords) {
    const coeffs = this.getCoefficients(coords);
    const a = coeffs[0];
    const b = coeffs[1];
    const c = coeffs[2];
    return "y = " + a.toFixed(3) + "x^2 + " + b.toFixed(3) + "x + " + c.toFixed(3);
  }
});
const Sinusoid = _.extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/3d68e7718498475f53b206c2ab285626baf8857e.png",
  defaultCoords: [[0.5, 0.5], [0.6, 0.6]],
  movable: MOVABLES.SINUSOID,
  getCoefficients: function (coords) {
    const p1 = coords[0];
    const p2 = coords[1];
    const a = p2[1] - p1[1];
    const b = Math.PI / (2 * (p2[0] - p1[0]));
    const c = p1[0] * b;
    const d = p1[1];
    return [a, b, c, d];
  },
  getFunctionForCoeffs: function (coeffs, x) {
    const a = coeffs[0];
    const b = coeffs[1];
    const c = coeffs[2];
    const d = coeffs[3];
    return a * Math.sin(b * x - c) + d;
  },
  getPropsForCoeffs: function (coeffs) {
    return {
      a: coeffs[0],
      b: coeffs[1],
      c: coeffs[2],
      d: coeffs[3]
    };
  },
  getEquationString: function (coords) {
    const coeffs = this.getCoefficients(coords);
    const a = coeffs[0];
    const b = coeffs[1];
    const c = coeffs[2];
    const d = coeffs[3];
    return "y = " + a.toFixed(3) + " sin(" + b.toFixed(3) + "x - " + c.toFixed(3) + ") + " + d.toFixed(3);
  },
  areEqual: function (coeffs1, coeffs2) {
    return approximateDeepEqual(canonicalSineCoefficients(coeffs1), canonicalSineCoefficients(coeffs2));
  }
});
const Tangent = _.extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/7db80d23c35214f98659fe1cf0765811c1bbfbba.png",
  defaultCoords: [[0.5, 0.5], [0.75, 0.75]],
  getCoefficients: function (coords) {
    const p1 = coords[0];
    const p2 = coords[1];
    const a = p2[1] - p1[1];
    const b = Math.PI / (4 * (p2[0] - p1[0]));
    const c = p1[0] * b;
    const d = p1[1];
    return [a, b, c, d];
  },
  getFunctionForCoeffs: function (coeffs, x) {
    const a = coeffs[0];
    const b = coeffs[1];
    const c = coeffs[2];
    const d = coeffs[3];
    return a * Math.tan(b * x - c) + d;
  },
  getEquationString: function (coords) {
    const coeffs = this.getCoefficients(coords);
    const a = coeffs[0];
    const b = coeffs[1];
    const c = coeffs[2];
    const d = coeffs[3];
    return "y = " + a.toFixed(3) + " sin(" + b.toFixed(3) + "x - " + c.toFixed(3) + ") + " + d.toFixed(3);
  },
  areEqual: function (coeffs1, coeffs2) {
    return approximateDeepEqual(canonicalTangentCoefficients(coeffs1), canonicalTangentCoefficients(coeffs2));
  }
});
const Exponential = _.extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/9cbfad55525e3ce755a31a631b074670a5dad611.png",
  defaultCoords: [[0.5, 0.55], [0.75, 0.75]],
  defaultAsymptote: [[0, 0.5], [1.0, 0.5]],
  /**
   * Add extra constraints for movement of the points or asymptote (below):
   *   newCoord: [x, y]
   *     The end position of the point or asymptote endpoint
   *   oldCoord: [x, y]
   *     The old position of the point or asymptote endpoint
   *   coords:
   *     An array of coordinates representing the proposed end configuration
   *     of the plot coordinates.
   *   asymptote:
   *     An array of coordinates representing the proposed end configuration
   *     of the asymptote.
   *
   * Return: either a coordinate (to be used as the resulting coordinate of
   * the move) or a boolean, where `true` uses newCoord as the resulting
   * coordinate, and `false` uses oldCoord as the resulting coordinate.
   */
  extraCoordConstraint: function (newCoord, oldCoord, coords, asymptote, graph) {
    const y = asymptote[0][1];
    return _.all(coords, coord => coord[1] !== y);
  },
  extraAsymptoteConstraint: function (newCoord, oldCoord, coords, asymptote, graph) {
    const y = newCoord[1];
    const isValid = _.all(coords, coord => coord[1] > y) || _.all(coords, coord => coord[1] < y);
    if (isValid) {
      return [oldCoord[0], y];
    }
    // Snap the asymptote as close as possible, i.e., if the user moves
    // the mouse really quickly into an invalid region
    const oldY = oldCoord[1];
    const wasBelow = _.all(coords, coord => coord[1] > oldY);
    if (wasBelow) {
      const bottomMost = _.min(_.map(coords, coord => coord[1]));
      return [oldCoord[0], bottomMost - graph.snapStep[1]];
    }
    const topMost = _.max(_.map(coords, coord => coord[1]));
    return [oldCoord[0], topMost + graph.snapStep[1]];
  },
  allowReflectOverAsymptote: true,
  getCoefficients: function (coords, asymptote) {
    const p1 = coords[0];
    const p2 = coords[1];
    const c = asymptote[0][1];
    const b = Math.log((p1[1] - c) / (p2[1] - c)) / (p1[0] - p2[0]);
    const a = (p1[1] - c) / Math.exp(b * p1[0]);
    return [a, b, c];
  },
  getFunctionForCoeffs: function (coeffs, x) {
    const a = coeffs[0];
    const b = coeffs[1];
    const c = coeffs[2];
    return a * Math.exp(b * x) + c;
  },
  getEquationString: function (coords, asymptote) {
    if (!asymptote) {
      return null;
    }
    const coeffs = this.getCoefficients(coords, asymptote);
    const a = coeffs[0];
    const b = coeffs[1];
    const c = coeffs[2];
    return "y = " + a.toFixed(3) + "e^(" + b.toFixed(3) + "x) + " + c.toFixed(3);
  }
});
const Logarithm = _.extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/f6491e99d34af34d924bfe0231728ad912068dc3.png",
  defaultCoords: [[0.55, 0.5], [0.75, 0.75]],
  defaultAsymptote: [[0.5, 0], [0.5, 1.0]],
  extraCoordConstraint: function (newCoord, oldCoord, coords, asymptote, graph) {
    const x = asymptote[0][0];
    return _.all(coords, coord => coord[0] !== x) && coords[0][1] !== coords[1][1];
  },
  extraAsymptoteConstraint: function (newCoord, oldCoord, coords, asymptote, graph) {
    const x = newCoord[0];
    const isValid = _.all(coords, coord => coord[0] > x) || _.all(coords, coord => coord[0] < x);
    if (isValid) {
      return [x, oldCoord[1]];
    }
    // Snap the asymptote as close as possible, i.e., if the user moves
    // the mouse really quickly into an invalid region
    const oldX = oldCoord[0];
    const wasLeft = _.all(coords, coord => coord[0] > oldX);
    if (wasLeft) {
      const leftMost = _.min(_.map(coords, coord => coord[0]));
      return [leftMost - graph.snapStep[0], oldCoord[1]];
    }
    const rightMost = _.max(_.map(coords, coord => coord[0]));
    return [rightMost + graph.snapStep[0], oldCoord[1]];
  },
  allowReflectOverAsymptote: true,
  getCoefficients: function (coords, asymptote) {
    // It's easiest to calculate the logarithm's coefficients by thinking
    // about it as the inverse of the exponential, so we flip x and y and
    // perform some algebra on the coefficients. This also unifies the
    // logic between the two 'models'.
    const flip = coord => [coord[1], coord[0]];
    const inverseCoeffs = Exponential.getCoefficients(_.map(coords, flip), _.map(asymptote, flip));
    if (inverseCoeffs) {
      const c = -inverseCoeffs[2] / inverseCoeffs[0];
      const b = 1 / inverseCoeffs[0];
      const a = 1 / inverseCoeffs[1];
      return [a, b, c];
    }
  },
  getFunctionForCoeffs: function (coeffs, x, asymptote) {
    const a = coeffs[0];
    const b = coeffs[1];
    const c = coeffs[2];
    return a * Math.log(b * x + c);
  },
  getEquationString: function (coords, asymptote) {
    if (!asymptote) {
      return null;
    }
    const coeffs = this.getCoefficients(coords, asymptote);
    const a = coeffs[0];
    const b = coeffs[1];
    const c = coeffs[2];
    return "y = ln(" + a.toFixed(3) + "x + " + b.toFixed(3) + ") + " + c.toFixed(3);
  }
});
const AbsoluteValue = _.extend({}, PlotDefaults, {
  url: "https://ka-perseus-graphie.s3.amazonaws.com/8256a630175a0cb1d11de223d6de0266daf98721.png",
  defaultCoords: [[0.5, 0.5], [0.75, 0.75]],
  getCoefficients: function (coords) {
    const p1 = coords[0];
    const p2 = coords[1];
    const denom = p2[0] - p1[0];
    const num = p2[1] - p1[1];
    if (denom === 0) {
      return;
    }
    let m = Math.abs(num / denom);
    if (p2[1] < p1[1]) {
      m *= -1;
    }
    const horizontalOffset = p1[0];
    const verticalOffset = p1[1];
    return [m, horizontalOffset, verticalOffset];
  },
  getFunctionForCoeffs: function (coeffs, x) {
    const m = coeffs[0];
    const horizontalOffset = coeffs[1];
    const verticalOffset = coeffs[2];
    return m * Math.abs(x - horizontalOffset) + verticalOffset;
  },
  getEquationString: function (coords) {
    const coeffs = this.getCoefficients(coords);
    const m = coeffs[0];
    const horizontalOffset = coeffs[1];
    const verticalOffset = coeffs[2];
    return "y = " + m.toFixed(3) + "| x - " + horizontalOffset.toFixed(3) + "| + " + verticalOffset.toFixed(3);
  }
});

/* Utility functions for dealing with graphing interfaces. */
const functionTypeMapping = {
  linear: Linear,
  quadratic: Quadratic,
  sinusoid: Sinusoid,
  tangent: Tangent,
  exponential: Exponential,
  logarithm: Logarithm,
  absolute_value: AbsoluteValue
};
const allTypes = _.keys(functionTypeMapping);
function functionForType(type) {
  // @ts-expect-error: TypeScript doesn't know how to use deal with generics
  // and conditional types in this way.
  return functionTypeMapping[type];
}

var grapherUtil = /*#__PURE__*/Object.freeze({
    __proto__: null,
    MOVABLES: MOVABLES,
    allTypes: allTypes,
    functionForType: functionForType
});

function isRealJSONParse(jsonParse) {
  const randomPhrase = buildRandomPhrase();
  const randomHintPhrase = buildRandomPhrase();
  const randomString = buildRandomString();
  const testingObject = JSON.stringify({
    answerArea: {
      calculator: false,
      chi2Table: false,
      financialCalculatorMonthlyPayment: false,
      financialCalculatorTimeToPayOff: false,
      financialCalculatorTotalAmount: false,
      periodicTable: false,
      periodicTableWithKey: false,
      tTable: false,
      zTable: false
    },
    hints: [randomHintPhrase, `=${Math.floor(Math.random() * 50) + 1}`],
    itemDataVersion: {
      major: 0,
      minor: 1
    },
    question: {
      content: `${randomPhrase}`,
      images: {},
      widgets: {
        expression1: {
          alignment: "default",
          graded: false,
          options: {
            answerForms: [{
              considered: "wrong",
              form: false,
              key: 0,
              simplify: false,
              value: `${randomString}`
            }],
            ariaLabel: "Answer",
            buttonSets: ["basic"],
            functions: ["f", "g", "h"],
            static: true,
            times: false,
            visibleLabel: "Answer"
          },
          static: true,
          type: "expression",
          version: {
            major: 1,
            minor: 0
          }
        }
      }
    }
  });
  const testJSON = buildTestData(testingObject.replace(/"/g, '\\"'));
  const parsedTestJSON = jsonParse(testJSON);
  const parsedTestItemData = parsedTestJSON.data.assessmentItem.item.itemData;
  return approximateDeepEqual(parsedTestItemData, testingObject);
}
function buildRandomString(capitalize = false) {
  let randomString = "";
  const randomLength = Math.floor(Math.random() * 8) + 3;
  for (let i = 0; i < randomLength; i++) {
    const randomLetter = String.fromCharCode(97 + Math.floor(Math.random() * 26));
    randomString += capitalize && i === 0 ? randomLetter.toUpperCase() : randomLetter;
  }
  return randomString;
}
function buildRandomPhrase() {
  const phrases = [];
  const randomLength = Math.floor(Math.random() * 10) + 5;
  for (let i = 0; i < randomLength; i++) {
    phrases.push(buildRandomString(i === 0));
  }
  const modifierStart = ["**", "$"];
  const modifierEnd = ["**", "$"];
  const modifierIndex = Math.floor(Math.random() * modifierStart.length);
  return `${modifierStart[modifierIndex]}${phrases.join(" ")}${modifierEnd[modifierIndex]}`;
}
function buildTestData(testObject) {
  return `{"data":{"assessmentItem":{"__typename":"AssessmentItemOrError","error":null,"item":{"__typename":"AssessmentItem","id":"x890b3c70f3e8f4a6","itemData":"${testObject}","problemType":"Type 1","sha":"c7284a3ad65214b4e62bccce236d92f7f5d35941"}}}}`;
}

process.env.NODE_ENV === 'production';

function success(value) {
  return {
    type: "success",
    value
  };
}
function failure(detail) {
  return {
    type: "failure",
    detail
  };
}
function isFailure(result) {
  return result.type === "failure";
}
function isSuccess(result) {
  return result.type === "success";
}

// Result's `all` function is similar to Promise.all: given an array of
// results, it returns success if all succeeded, and failure if any failed.
function all(results, combineFailureDetails = a => a) {
  const values = [];
  const failureDetails = [];
  for (const result of results) {
    if (result.type === "success") {
      values.push(result.value);
    } else {
      failureDetails.push(result.detail);
    }
  }
  if (failureDetails.length > 0) {
    return failure(failureDetails.reduce(combineFailureDetails));
  }
  return success(values);
}

class ErrorTrackingParseContext {
  constructor(path) {
    this.path = path;
  }
  failure(expected, badValue) {
    return failure([{
      expected: wrapInArray(expected),
      badValue,
      path: this.path
    }]);
  }
  forSubtree(key) {
    return new ErrorTrackingParseContext([...this.path, key]);
  }
  success(value) {
    return success(value);
  }
}
function wrapInArray(a) {
  return Array.isArray(a) ? a : [a];
}

function formatPath(path) {
  return "(root)" + path.map(formatPathSegment).join("");
}
function formatPathSegment(segment) {
  if (typeof segment === "string") {
    return validIdentifier.test(segment) ? "." + segment : `[${JSON.stringify(segment)}]`;
  }
  return `[${segment.toString()}]`;
}
const validIdentifier = /^[A-Za-z$_][A-Za-z$_0-9]*$/;

function message(failure) {
  const expected = conjoin(failure.expected);
  const path = formatPath(failure.path);
  const badValue = JSON.stringify(failure.badValue);
  return `At ${path} -- expected ${expected}, but got ${badValue}`;
}
function conjoin(items) {
  switch (items.length) {
    // TODO(benchristel): handle 0 if this is reused elsewhere.
    case 1:
      return items[0];
    case 2:
      return items.join(" or ");
    default:
      {
        const allButLast = items.slice(0, items.length - 1);
        const last = items[items.length - 1];
        return allButLast.join(", ") + ", or " + last;
      }
  }
}

function parse(value, parser) {
  const result = parser(value, new ErrorTrackingParseContext([]));
  if (isFailure(result)) {
    return failure(result.detail.map(message).join("; "));
  }
  return result;
}

const any = (rawValue, ctx) => ctx.success(rawValue);

function array(elementParser) {
  return (rawValue, ctx) => {
    if (!Array.isArray(rawValue)) {
      return ctx.failure("array", rawValue);
    }
    const elementResults = rawValue.map((elem, i) => elementParser(elem, ctx.forSubtree(i)));
    return all(elementResults, concat);
  };
}
function concat(a, b) {
  return [...a, ...b];
}

function boolean(rawValue, ctx) {
  if (typeof rawValue === "boolean") {
    return ctx.success(rawValue);
  }
  return ctx.failure("boolean", rawValue);
}

function constant(acceptedValue) {
  return (rawValue, ctx) => {
    if (rawValue !== acceptedValue) {
      return ctx.failure(String(JSON.stringify(acceptedValue)), rawValue);
    }
    return ctx.success(acceptedValue);
  };
}

function enumeration(...acceptedValues) {
  return (rawValue, ctx) => {
    if (typeof rawValue === "string") {
      const index = acceptedValues.indexOf(rawValue);
      if (index > -1) {
        return ctx.success(acceptedValues[index]);
      }
    }
    const expected = acceptedValues.map(v => JSON.stringify(v));
    return ctx.failure(expected, rawValue);
  };
}

function isObject(x) {
  return x != null && Object.getPrototypeOf(x) === Object.prototype;
}

function nullable(parseValue) {
  return (rawValue, ctx) => {
    if (rawValue === null) {
      return ctx.success(rawValue);
    }
    return parseValue(rawValue, ctx);
  };
}

const number = (rawValue, ctx) => {
  if (typeof rawValue === "number") {
    return ctx.success(rawValue);
  }
  return ctx.failure("number", rawValue);
};

function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

function object(schema) {
  return (rawValue, ctx) => {
    if (!isObject(rawValue)) {
      return ctx.failure("object", rawValue);
    }
    const ret = _extends({}, rawValue);
    const mismatches = [];
    for (const [prop, propParser] of Object.entries(schema)) {
      const result = propParser(rawValue[prop], ctx.forSubtree(prop));
      if (isSuccess(result)) {
        if (result.value !== undefined || prop in rawValue) {
          ret[prop] = result.value;
        }
      } else {
        mismatches.push(...result.detail);
      }
    }
    if (mismatches.length > 0) {
      return failure(mismatches);
    }
    return ctx.success(ret);
  };
}

function optional(parseValue) {
  return (rawValue, ctx) => {
    if (rawValue === undefined) {
      return ctx.success(rawValue);
    }
    return parseValue(rawValue, ctx);
  };
}

function pair(parseA, parseB) {
  return (rawValue, ctx) => {
    if (!Array.isArray(rawValue)) {
      return ctx.failure("array", rawValue);
    }
    if (rawValue.length !== 2) {
      return ctx.failure("array of length 2", rawValue);
    }
    const [rawA, rawB] = rawValue;
    const resultA = parseA(rawA, ctx.forSubtree(0));
    if (isFailure(resultA)) {
      return resultA;
    }
    const resultB = parseB(rawB, ctx.forSubtree(1));
    if (isFailure(resultB)) {
      return resultB;
    }
    return ctx.success([resultA.value, resultB.value]);
  };
}

function pipeParsers(p) {
  return new ParserPipeline(p);
}
class ParserPipeline {
  constructor(parser) {
    this.parser = parser;
  }
  then(nextParser) {
    return new ParserPipeline(composeParsers(this.parser, nextParser));
  }
}
function composeParsers(parserA, parserB) {
  return (rawValue, ctx) => {
    const partialResult = parserA(rawValue, ctx);
    if (isFailure(partialResult)) {
      return partialResult;
    }
    return parserB(partialResult.value, ctx);
  };
}

function record(parseKey, parseValue) {
  return (rawValue, ctx) => {
    if (!isObject(rawValue)) {
      return ctx.failure("object", rawValue);
    }
    const result = {};
    const mismatches = [];
    for (const [key, value] of Object.entries(rawValue)) {
      const entryCtx = ctx.forSubtree(key);
      const keyResult = parseKey(key, entryCtx);
      if (isFailure(keyResult)) {
        mismatches.push(...keyResult.detail);
      }
      const valueResult = parseValue(value, entryCtx);
      if (isFailure(valueResult)) {
        mismatches.push(...valueResult.detail);
      }
      if (isSuccess(keyResult) && isSuccess(valueResult)) {
        result[keyResult.value] = valueResult.value;
      }
    }
    if (mismatches.length > 0) {
      return failure(mismatches);
    }
    return ctx.success(result);
  };
}

const string = (rawValue, ctx) => {
  if (typeof rawValue === "string") {
    return ctx.success(rawValue);
  }
  return ctx.failure("string", rawValue);
};

function trio(parseA, parseB, parseC) {
  return (rawValue, ctx) => {
    if (!Array.isArray(rawValue)) {
      return ctx.failure("array", rawValue);
    }
    if (rawValue.length !== 3) {
      return ctx.failure("array of length 3", rawValue);
    }
    const resultA = parseA(rawValue[0], ctx.forSubtree(0));
    if (isFailure(resultA)) {
      return resultA;
    }
    const resultB = parseB(rawValue[1], ctx.forSubtree(1));
    if (isFailure(resultB)) {
      return resultB;
    }
    const resultC = parseC(rawValue[2], ctx.forSubtree(2));
    if (isFailure(resultC)) {
      return resultC;
    }
    return ctx.success([resultA.value, resultB.value, resultC.value]);
  };
}

function union(parseBranch) {
  return new UnionBuilder(parseBranch);
}
class UnionBuilder {
  constructor(parser) {
    this.parser = parser;
  }
  or(newBranch) {
    return new UnionBuilder(either(this.parser, newBranch));
  }
}
function either(parseA, parseB) {
  return (rawValue, ctx) => {
    const resultA = parseA(rawValue, ctx);
    if (isSuccess(resultA)) {
      return resultA;
    }
    return parseB(rawValue, ctx);
  };
}

function defaulted(parser, fallback) {
  return (rawValue, ctx) => {
    if (rawValue == null) {
      return success(fallback(rawValue));
    }
    return parser(rawValue, ctx);
  };
}

const parseImages = defaulted(record(string, object({
  width: number,
  height: number
})), () => ({}));

function parseWidget(parseType, parseOptions) {
  return object({
    type: parseType,
    static: optional(boolean),
    graded: optional(boolean),
    alignment: optional(string),
    options: parseOptions,
    key: optional(nullable(number)),
    version: optional(object({
      major: number,
      minor: number
    }))
  });
}
function parseWidgetWithVersion(parseVersion, parseType, parseOptions) {
  return object({
    type: parseType,
    static: optional(boolean),
    graded: optional(boolean),
    alignment: optional(string),
    options: parseOptions,
    key: optional(number),
    version: parseVersion
  });
}

const parseCategorizerWidget = parseWidget(constant("categorizer"), object({
  items: array(string),
  categories: array(string),
  randomizeItems: defaulted(boolean, () => false),
  static: defaulted(boolean, () => false),
  values: array(defaulted(number, () => 0)),
  highlightLint: optional(boolean),
  linterContext: optional(object({
    contentType: string,
    paths: array(string),
    stack: array(string)
  }))
}));

const parseCSProgramWidget = parseWidget(constant("cs-program"), object({
  programID: string,
  programType: any,
  settings: array(object({
    name: string,
    value: string
  })),
  showEditor: boolean,
  showButtons: boolean,
  height: number,
  static: defaulted(boolean, () => false)
}));

const parseDefinitionWidget = parseWidget(constant("definition"), object({
  togglePrompt: string,
  definition: string,
  static: defaulted(boolean, () => false)
}));

const parseDropdownWidget = parseWidget(constant("dropdown"), object({
  placeholder: defaulted(string, () => ""),
  ariaLabel: optional(string),
  visibleLabel: optional(string),
  static: defaulted(boolean, () => false),
  choices: array(object({
    content: string,
    correct: boolean
  }))
}));

const parseExplanationWidget = parseWidget(constant("explanation"), object({
  showPrompt: string,
  hidePrompt: string,
  explanation: string,
  // We wrap parseWidgetsMap in a function here to make sure it is not
  // referenced before it is defined. There is an import cycle between
  // this file and widgets-map.ts that could cause it to be undefined.
  widgets: defaulted((rawVal, ctx) => parseWidgetsMap(rawVal, ctx), () => ({})),
  static: defaulted(boolean, () => false)
}));

// Given a function, creates a PartialParser that converts one type to another
// using that function. The returned parser never fails.
function convert(f) {
  return (rawValue, ctx) => ctx.success(f(rawValue));
}

const parseLegacyButtonSet = enumeration("basic", "basic+div", "trig", "prealgebra", "logarithms", "basic relations", "advanced relations", "scientific");
const parseLegacyButtonSets = defaulted(array(parseLegacyButtonSet),
// NOTE(benchristel): I copied the default buttonSets from
// expression.tsx. See the parse-perseus-json/README.md for
// an explanation of why we want to duplicate the default here.
() => ["basic", "trig", "prealgebra", "logarithms"]);

/**
 * Creates a parser for a widget options type with multiple major versions. Old
 * versions are migrated to the latest version. The parse fails if the input
 * data does not match any of the versions.
 *
 * @example
 * const parseOptions = versionedWidgetOptions(3, parseOptionsV3)
 *     .withMigrationFrom(2, parseOptionsV2, migrateV2ToV3)
 *     .withMigrationFrom(1, parseOptionsV1, migrateV1ToV2)
 *     .withMigrationFrom(0, parseOptionsV0, migrateV0ToV1)
 *     .parser;
 *
 * @param latestMajorVersion the latest major version of the widget options.
 * @param parseLatest a {@link Parser} for the latest version of the widget
 * options.
 * @returns a builder object, to which migrations from earlier versions can be
 * added. Migrations must be added in "reverse chronological" order as in the
 * example above.
 */
function versionedWidgetOptions(latestMajorVersion, parseLatest) {
  return new VersionedWidgetOptionsParserBuilder(latestMajorVersion, parseLatest, latest => latest, (raw, ctx) => ctx.failure("widget options with a known version number", raw));
}
class VersionedWidgetOptionsParserBuilder {
  constructor(majorVersion, parseThisVersion, migrateToLatest, parseOtherVersions) {
    this.parser = void 0;
    this.migrateToLatest = migrateToLatest;
    this.parseOtherVersions = parseOtherVersions;
    const parseThisVersionAndMigrateToLatest = pipeParsers(parseThisVersion).then(convert(this.migrateToLatest)).parser;
    this.parser = (raw, ctx) => {
      if (!isObject(raw)) {
        return ctx.failure("object", raw);
      }
      const versionParseResult = parseVersionedObject(raw, ctx);
      if (isFailure(versionParseResult)) {
        return versionParseResult;
      }
      if (versionParseResult.value.version.major !== majorVersion) {
        return this.parseOtherVersions(raw, ctx);
      }
      return parseThisVersionAndMigrateToLatest(raw, ctx);
    };
  }

  /**
   * Add a migration from an old version of the widget options.
   */
  withMigrationFrom(majorVersion, parseOldVersion, migrateToNextVersion) {
    const parseOtherVersions = this.parser;
    const migrateToLatest = old => this.migrateToLatest(migrateToNextVersion(old));
    return new VersionedWidgetOptionsParserBuilder(majorVersion, parseOldVersion, migrateToLatest, parseOtherVersions);
  }
}
const parseVersionedObject = object({
  version: defaulted(object({
    major: number,
    minor: number
  }), () => ({
    major: 0,
    minor: 0
  }))
});

const stringOrNumberOrNullOrUndefined = union(string).or(number).or(constant(null)).or(constant(undefined)).parser;
const parsePossiblyInvalidAnswerForm = object({
  // `value` is the possibly invalid part of this. It should always be a
  // string, but some answer forms don't have it. The Expression widget
  // ignores invalid values, so we can safely filter them out during parsing.
  value: optional(string),
  form: defaulted(boolean, () => false),
  simplify: defaulted(boolean, () => false),
  considered: enumeration("correct", "wrong", "ungraded"),
  key: pipeParsers(stringOrNumberOrNullOrUndefined).then(convert(String)).parser
});
function removeInvalidAnswerForms(possiblyInvalid) {
  const valid = [];
  for (const answerForm of possiblyInvalid) {
    const {
      value
    } = answerForm;
    if (value != null) {
      // Copying the object seems to be needed to make TypeScript happy
      valid.push(_extends({}, answerForm, {
        value
      }));
    }
  }
  return valid;
}
const version1 = object({
  major: constant(1),
  minor: number
});
const parseExpressionWidgetV1 = parseWidgetWithVersion(version1, constant("expression"), object({
  answerForms: pipeParsers(array(parsePossiblyInvalidAnswerForm)).then(convert(removeInvalidAnswerForms)).parser,
  functions: array(string),
  times: boolean,
  visibleLabel: optional(string),
  ariaLabel: optional(string),
  buttonSets: parseLegacyButtonSets,
  buttonsVisible: optional(enumeration("always", "never", "focused"))
}));
const version0 = optional(object({
  major: constant(0),
  minor: number
}));
const parseExpressionWidgetV0 = parseWidgetWithVersion(version0, constant("expression"), object({
  functions: array(string),
  times: boolean,
  visibleLabel: optional(string),
  ariaLabel: optional(string),
  form: boolean,
  simplify: boolean,
  value: string,
  buttonSets: parseLegacyButtonSets,
  buttonsVisible: optional(enumeration("always", "never", "focused"))
}));
function migrateV0ToV1(widget) {
  const {
    options
  } = widget;
  return _extends({}, widget, {
    version: {
      major: 1,
      minor: 0
    },
    options: {
      times: options.times,
      buttonSets: options.buttonSets,
      functions: options.functions,
      buttonsVisible: options.buttonsVisible,
      visibleLabel: options.visibleLabel,
      ariaLabel: options.ariaLabel,
      answerForms: [{
        considered: "correct",
        form: options.form,
        simplify: options.simplify,
        value: options.value
      }]
    }
  });
}
const parseExpressionWidget = versionedWidgetOptions(1, parseExpressionWidgetV1).withMigrationFrom(0, parseExpressionWidgetV0, migrateV0ToV1).parser;

const falseToNull = pipeParsers(constant(false)).then(convert(() => null)).parser;
const parseGradedGroupWidgetOptions = object({
  title: defaulted(string, () => ""),
  hasHint: optional(nullable(boolean)),
  // This module has an import cycle with parsePerseusRenderer.
  // The anonymous function below ensures that we don't try to access
  // parsePerseusRenderer before it's defined.
  hint: union(falseToNull).or(constant(null)).or(constant(undefined)).or((rawVal, ctx) => parsePerseusRenderer(rawVal, ctx)).parser,
  content: string,
  // This module has an import cycle with parseWidgetsMap.
  // The anonymous function below ensures that we don't try to access
  // parseWidgetsMap before it's defined.
  widgets: (rawVal, ctx) => parseWidgetsMap(rawVal, ctx),
  widgetEnabled: optional(nullable(boolean)),
  immutableWidgets: optional(nullable(boolean)),
  images: record(string, object({
    width: number,
    height: number
  }))
});
const parseGradedGroupWidget = parseWidget(constant("graded-group"), parseGradedGroupWidgetOptions);

const parseGradedGroupSetWidget = parseWidget(constant("graded-group-set"), object({
  gradedGroups: array(parseGradedGroupWidgetOptions)
}));

/**
 * discriminatedUnion() should be preferred over union() when parsing a
 * discriminated union type, because discriminatedUnion() produces more
 * understandable failure messages. It takes the discriminant as the source of
 * truth for which variant is to be parsed, and expects the other data to match
 * that variant.
 */
function discriminatedUnionOn(discriminantKey) {
  const noMoreBranches = (raw, ctx) => {
    if (!isObject(raw)) {
      return ctx.failure("object", raw);
    }
    return ctx.forSubtree(discriminantKey).failure("a valid value", raw[discriminantKey]);
  };
  return new DiscriminatedUnionBuilder(discriminantKey, noMoreBranches);
}
class DiscriminatedUnionBuilder {
  constructor(discriminantKey, parser) {
    this.discriminantKey = discriminantKey;
    this.parser = parser;
  }
  withBranch(discriminantValue, parseNewVariant) {
    const parseNewBranch = discriminatedUnionBranch(this.discriminantKey, discriminantValue, parseNewVariant, this.parser);
    return new DiscriminatedUnionBuilder(this.discriminantKey, parseNewBranch);
  }
}
function discriminatedUnionBranch(discriminantKey, discriminantValue, parseVariant, parseOtherBranches) {
  return (raw, ctx) => {
    if (!isObject(raw)) {
      return ctx.failure("object", raw);
    }
    if (raw[discriminantKey] === discriminantValue) {
      return parseVariant(raw, ctx);
    }
    return parseOtherBranches(raw, ctx);
  };
}

const pairOfNumbers$3 = pair(number, number);
const pairOfPoints = pair(pairOfNumbers$3, pairOfNumbers$3);
const parseGrapherWidget = parseWidget(constant("grapher"), object({
  availableTypes: array(enumeration("absolute_value", "exponential", "linear", "logarithm", "quadratic", "sinusoid", "tangent")),
  correct: discriminatedUnionOn("type").withBranch("absolute_value", object({
    type: constant("absolute_value"),
    coords: nullable(pairOfPoints)
  })).withBranch("exponential", object({
    type: constant("exponential"),
    asymptote: pairOfPoints,
    coords: nullable(pairOfPoints)
  })).withBranch("linear", object({
    type: constant("linear"),
    coords: nullable(pairOfPoints)
  })).withBranch("logarithm", object({
    type: constant("logarithm"),
    asymptote: pairOfPoints,
    coords: nullable(pairOfPoints)
  })).withBranch("quadratic", object({
    type: constant("quadratic"),
    coords: nullable(pairOfPoints)
  })).withBranch("sinusoid", object({
    type: constant("sinusoid"),
    coords: nullable(pairOfPoints)
  })).withBranch("tangent", object({
    type: constant("tangent"),
    coords: nullable(pairOfPoints)
  })).parser,
  graph: object({
    backgroundImage: object({
      bottom: optional(number),
      height: optional(number),
      left: optional(number),
      scale: optional(number),
      url: optional(nullable(string)),
      width: optional(number)
    }),
    box: optional(pairOfNumbers$3),
    editableSettings: optional(array(enumeration("graph", "snap", "image", "measure"))),
    gridStep: optional(pairOfNumbers$3),
    labels: pair(string, string),
    markings: enumeration("graph", "none", "grid"),
    range: pair(pairOfNumbers$3, pairOfNumbers$3),
    rulerLabel: constant(""),
    rulerTicks: number,
    showProtractor: optional(boolean),
    showRuler: optional(boolean),
    showTooltips: optional(boolean),
    snapStep: optional(pairOfNumbers$3),
    step: pairOfNumbers$3,
    valid: optional(union(boolean).or(string).parser)
  })
}));

const parseGroupWidget = parseWidget(constant("group"),
// This module has an import cycle with parsePerseusRenderer.
// The anonymous function below ensures that we don't try to access
// parsePerseusRenderer before it's defined.
(rawVal, ctx) => parsePerseusRenderer(rawVal, ctx));

const parseIframeWidget = parseWidget(constant("iframe"), object({
  url: string,
  settings: optional(array(object({
    name: string,
    value: string
  }))),
  width: union(number).or(string).parser,
  height: union(number).or(string).parser,
  allowFullScreen: defaulted(boolean, () => false),
  allowTopNavigation: optional(boolean),
  static: defaulted(boolean, () => false)
}));

const stringToNumber = (rawValue, ctx) => {
  if (typeof rawValue === "number") {
    return ctx.success(rawValue);
  }
  const parsedNumber = +rawValue;
  if (rawValue === "" || isNaN(parsedNumber)) {
    return ctx.failure("a number or numeric string", rawValue);
  }
  return ctx.success(parsedNumber);
};

function emptyToZero(x) {
  return x === "" ? 0 : x;
}
const imageDimensionToNumber = pipeParsers(union(number).or(string).parser)
// In this specific case, empty string is equivalent to zero. An empty
// string parses to either NaN (using parseInt) or 0 (using unary +) and
// CSS will treat NaN as invalid and default to 0 instead.
.then(convert(emptyToZero)).then(stringToNumber).parser;
const dimensionOrUndefined = defaulted(imageDimensionToNumber, () => undefined);
const parsePerseusImageBackground = object({
  url: optional(nullable(string)),
  width: dimensionOrUndefined,
  height: dimensionOrUndefined,
  top: dimensionOrUndefined,
  left: dimensionOrUndefined,
  bottom: dimensionOrUndefined,
  scale: dimensionOrUndefined
});

const pairOfNumbers$2 = pair(number, number);
const parseImageWidget = parseWidget(constant("image"), object({
  title: optional(string),
  caption: optional(string),
  alt: optional(string),
  backgroundImage: parsePerseusImageBackground,
  static: optional(boolean),
  labels: optional(array(object({
    content: string,
    alignment: string,
    coordinates: array(number)
  }))),
  range: optional(pair(pairOfNumbers$2, pairOfNumbers$2)),
  box: optional(pairOfNumbers$2)
}));

const booleanToString = (rawValue, ctx) => {
  if (typeof rawValue === "boolean") {
    return ctx.success(String(rawValue));
  }
  return ctx.failure("boolean", rawValue);
};
const parseInputNumberWidget = parseWidget(constant("input-number"), object({
  answerType: optional(enumeration("number", "decimal", "integer", "rational", "improper", "mixed", "percent", "pi")),
  inexact: optional(boolean),
  maxError: optional(union(number).or(string).parser),
  rightAlign: optional(boolean),
  simplify: enumeration("required", "optional", "enforced"),
  size: enumeration("normal", "small"),
  // TODO(benchristel): there are some content items where value is a
  // boolean, even though that makes no sense. We should figure out if
  // those content items are actually published anywhere, and consider
  // updating them.
  value: union(number).or(string).or(booleanToString).parser,
  customKeypad: optional(boolean)
}));

const pairOfNumbers$1 = pair(number, number);
const stringOrEmpty = defaulted(string, () => "");
const parseKey = pipeParsers(optional(string)).then(convert(String)).parser;
const parseFunctionElement = object({
  type: constant("function"),
  key: parseKey,
  options: object({
    value: string,
    funcName: string,
    rangeMin: string,
    rangeMax: string,
    color: string,
    strokeDasharray: string,
    strokeWidth: number
  })
});
const parseLabelElement = object({
  type: constant("label"),
  key: parseKey,
  options: object({
    label: string,
    color: string,
    coordX: string,
    coordY: string
  })
});
const parseLineElement = object({
  type: constant("line"),
  key: parseKey,
  options: object({
    color: string,
    startX: string,
    startY: string,
    endX: string,
    endY: string,
    strokeDasharray: string,
    strokeWidth: number,
    arrows: string
  })
});
const parseMovableLineElement = object({
  type: constant("movable-line"),
  key: parseKey,
  options: object({
    startX: string,
    startY: string,
    startSubscript: number,
    endX: string,
    endY: string,
    endSubscript: number,
    constraint: string,
    snap: number,
    constraintFn: string,
    constraintXMin: string,
    constraintXMax: string,
    constraintYMin: string,
    constraintYMax: string
  })
});
const parseMovablePointElement = object({
  type: constant("movable-point"),
  key: parseKey,
  options: object({
    startX: string,
    startY: string,
    varSubscript: number,
    constraint: string,
    snap: number,
    constraintFn: string,
    constraintXMin: stringOrEmpty,
    constraintXMax: stringOrEmpty,
    constraintYMin: stringOrEmpty,
    constraintYMax: stringOrEmpty
  })
});
const parseParametricElement = object({
  type: constant("parametric"),
  key: parseKey,
  options: object({
    x: string,
    y: string,
    rangeMin: string,
    rangeMax: string,
    color: string,
    strokeDasharray: string,
    strokeWidth: number
  })
});
const parsePointElement = object({
  type: constant("point"),
  key: parseKey,
  options: object({
    color: string,
    coordX: string,
    coordY: string
  })
});
const parseRectangleElement = object({
  type: constant("rectangle"),
  key: parseKey,
  options: object({
    color: string,
    coordX: string,
    coordY: string,
    width: string,
    height: string
  })
});
const parseInteractionWidget = parseWidget(constant("interaction"), object({
  static: defaulted(boolean, () => false),
  graph: object({
    editableSettings: optional(array(enumeration("canvas", "graph"))),
    box: pairOfNumbers$1,
    labels: array(string),
    range: pair(pairOfNumbers$1, pairOfNumbers$1),
    gridStep: pairOfNumbers$1,
    markings: enumeration("graph", "grid", "none"),
    snapStep: optional(pairOfNumbers$1),
    valid: optional(union(boolean).or(string).parser),
    backgroundImage: optional(parsePerseusImageBackground),
    showProtractor: optional(boolean),
    showRuler: optional(boolean),
    rulerLabel: optional(string),
    rulerTicks: optional(number),
    tickStep: pairOfNumbers$1
  }),
  elements: array(discriminatedUnionOn("type").withBranch("function", parseFunctionElement).withBranch("label", parseLabelElement).withBranch("line", parseLineElement).withBranch("movable-line", parseMovableLineElement).withBranch("movable-point", parseMovablePointElement).withBranch("parametric", parseParametricElement).withBranch("point", parsePointElement).withBranch("rectangle", parseRectangleElement).parser)
}));

/**
 * The Perseus "data schema" file.
 *
 * This file, and the types in it, represents the "data schema" that Perseus
 * uses. The @khanacademy/perseus-editor package edits and produces objects
 * that conform to the types in this file. Similarly, the top-level renderers
 * in @khanacademy/perseus, consume objects that conform to these types.
 *
 * WARNING: This file should not import any types from elsewhere so that it is
 * easy to reason about changes that alter the Perseus schema. This helps
 * ensure that it is not changed accidentally when upgrading a dependant
 * package or other part of Perseus code. Note that TypeScript does type
 * checking via something called "structural typing". This means that as long
 * as the shape of a type matches, the name it goes by doesn't matter. As a
 * result, a `Coord` type that looks like this `[x: number, y: number]` is
 * _identical_, in TypeScript's eyes, to this `Vector2` type `[x: number, y:
 * number]`. Also, with tuples, the labels for each entry is ignored, so `[x:
 * number, y: number]` is compatible with `[min: number, max: number]`. The
 * labels are for humans, not TypeScript. :)
 *
 * If you make changes to types in this file, be very sure that:
 *
 *   a) the changes are backwards compatible. If they are not, old data from
 *      previous versions of the "schema" could become unrenderable, or worse,
 *      introduce hard-to-diagnose bugs.
 *   b) the parsing code (`util/parse-perseus-json/`) is updated to handle
 *      the new format _as well as_ the old format.
 */

// TODO(FEI-4010): Remove `Perseus` prefix for all types here

// Same name as Mafs

/**
 * A utility type that constructs a widget map from a "registry interface".
 * The keys of the registry should be the widget type (aka, "categorizer" or
 * "radio", etc) and the value should be the option type stored in the value
 * of the map.
 *
 * You can think of this as a type that generates another type. We use
 * "registry interfaces" as a way to keep a set of widget types to their data
 * type in several places in Perseus. This type then allows us to generate a
 * map type that maps a widget id to its data type and keep strong typing by
 * widget id.
 *
 * For example, given a fictitious registry such as this:
 *
 * ```
 * interface DummyRegistry {
 *     categorizer: { categories: ReadonlyArray<string> };
 *     dropdown: { choices: ReadonlyArray<string> }:
 * }
 * ```
 *
 * If we create a DummyMap using this helper:
 *
 * ```
 * type DummyMap = MakeWidgetMap<DummyRegistry>;
 * ```
 *
 * We'll get a map that looks like this:
 *
 * ```
 * type DummyMap = {
 *     `categorizer ${number}`: { categories: ReadonlyArray<string> };
 *     `dropdown ${number}`: { choices: ReadonlyArray<string> };
 * }
 * ```
 *
 * We use interfaces for the registries so that they can be extended in cases
 * where the consuming app brings along their own widgets. Interfaces in
 * TypeScript are always open (ie. you can extend them) whereas types aren't.
 */

/**
 * Our core set of Perseus widgets.
 *
 * This interface is the basis for "registering" all Perseus widget types.
 * There should be one key/value pair for each supported widget. If you create
 * a new widget, an entry should be added to this interface. Note that this
 * only registers the widget options type, you'll also need to register the
 * widget so that it's available at runtime (@see
 * {@link file://./widgets.ts#registerWidget}).
 *
 * Importantly, the key should be the name that is used in widget IDs. For most
 * widgets that is the same as the widget option's `type` field. In cases where
 * a widget has been deprecated and replaced with the deprecated-standin
 * widget, it should be the original widget type!
 *
 * If you define the widget outside of this package, you can still add the new
 * widget to this interface by writing the following in that package that
 * contains the widget. TypeScript will merge that definition of the
 * `PerseusWidgets` with the one defined below.
 *
 * ```typescript
 * declare module "@khanacademy/perseus-core" {
 *     interface PerseusWidgetTypes {
 *         // A new widget
 *         "new-awesomeness": MyAwesomeNewWidget;
 *
 *         // A deprecated widget
 *         "super-old-widget": DeprecatedStandinWidget;
 *     }
 * }
 *
 * // The new widget's options definition
 * type MyAwesomeNewWidget = WidgetOptions<'new-awesomeness', MyAwesomeNewWidgetOptions>;
 *
 * // The deprecated widget's options definition
 * type SuperOldWidget = WidgetOptions<'super-old-widget', object>;
 * ```
 *
 * This interface can be extended through the magic of TypeScript "Declaration
 * merging". Specifically, we augment this module and extend this interface.
 *
 * @see {@link https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation}
 */

/**
 * A map of widget IDs to widget options. This is most often used as the type
 * for a set of widgets defined in a `PerseusItem` but can also be useful to
 * represent a function parameter where only `widgets` from a `PerseusItem` are
 * needed. Today Widget IDs are made up of the widget type and an incrementing
 * integer (eg. `interactive-graph 1` or `radio 3`). It is suggested to avoid
 * reading/parsing the widget id to derive any information from it, except in
 * the case of this map.
 *
 * @see {@link PerseusWidgetTypes} additional widgets can be added to this map type
 * by augmenting the PerseusWidgetTypes with new widget types!
 */

/**
 * PerseusWidget is a union of all the different types of widget options that
 * Perseus knows about.
 *
 * Thanks to it being based on PerseusWidgetTypes interface, this union is
 * automatically extended to include widgets used in tests without those widget
 * option types seeping into our production types.
 *
 * @see MockWidget for an example
 */

/**
 * A "PerseusItem" is a classic Perseus item. It is rendered by the
 * `ServerItemRenderer` and the layout is pre-set.
 *
 * To render more complex Perseus items, see the `Item` type in the multi item
 * area.
 */

/**
 * A "PerseusArticle" is an item that is meant to be rendered as an article.
 * This item is never scored and is rendered by the `ArticleRenderer`.
 */

const ItemExtras = [
// The user might benefit from using a Scientific Calculator.  Provided on Khan Academy when true
"calculator",
// The user might benefit from using a statistics Chi Squared Table like https://people.richland.edu/james/lecture/m170/tbl-chi.html
"chi2Table",
// The user might benefit from a monthly payments calculator.  Provided on Khan Academy when true
"financialCalculatorMonthlyPayment",
// The user might benefit from a total amount calculator.  Provided on Khan Academy when true
"financialCalculatorTotalAmount",
// The user might benefit from a time to pay off calculator.  Provided on Khan Academy when true
"financialCalculatorTimeToPayOff",
// The user might benefit from using a Periodic Table of Elements.  Provided on Khan Academy when true
"periodicTable",
// The user might benefit from using a Periodic Table of Elements with key.  Provided on Khan Academy when true
"periodicTableWithKey",
// The user might benefit from using a statistics T Table like https://www.statisticshowto.com/tables/t-distribution-table/
"tTable",
// The user might benefit from using a statistics Z Table like https://www.ztable.net/
"zTable"];

/**
 * The type representing the common structure of all widget's options. The
 * `Options` generic type represents the widget-specific option data.
 */

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

// prettier-ignore

//prettier-ignore

/**
 * A background image applied to various widgets.
 */

/**
 * The type of markings to display on the graph.
 * - axes: shows the axes without the gride lines
 * - graph: shows the axes and the grid lines
 * - grid: shows only the grid lines
 * - none: shows no markings
 */

const PerseusExpressionAnswerFormConsidered = ["correct", "wrong", "ungraded"];

// 2D range: xMin, xMax, yMin, yMax

const lockedFigureColorNames = ["blue", "green", "grayH", "purple", "pink", "orange", "red"];
const lockedFigureColors = {
  blue: "#3D7586",
  green: "#447A53",
  grayH: "#3B3D45",
  purple: "#594094",
  pink: "#B25071",
  red: "#D92916",
  orange: "#946700"
};
const lockedFigureFillStyles = {
  none: 0,
  white: 1,
  translucent: 0.4,
  solid: 1
};

// Not associated with a specific figure

const plotterPlotTypes = ["bar", "line", "pic", "histogram", "dotplot"];

// Used to represent 2-D points and ranges
const pairOfNumbers = pair(number, number);
const parsePerseusGraphTypeAngle = object({
  type: constant("angle"),
  showAngles: optional(boolean),
  allowReflexAngles: optional(boolean),
  angleOffsetDeg: optional(number),
  snapDegrees: optional(number),
  match: optional(constant("congruent")),
  coords: optional(trio(pairOfNumbers, pairOfNumbers, pairOfNumbers)),
  startCoords: optional(trio(pairOfNumbers, pairOfNumbers, pairOfNumbers))
});
const parsePerseusGraphTypeCircle = object({
  type: constant("circle"),
  center: optional(pairOfNumbers),
  radius: optional(number),
  startCoords: optional(object({
    center: pairOfNumbers,
    radius: number
  })),
  // TODO: remove coord? it's legacy.
  coord: optional(pairOfNumbers)
});
const parsePerseusGraphTypeLinear = object({
  type: constant("linear"),
  coords: optional(nullable(pair(pairOfNumbers, pairOfNumbers))),
  startCoords: optional(pair(pairOfNumbers, pairOfNumbers)),
  // TODO: remove coord? it's legacy.
  coord: optional(pairOfNumbers)
});
const parsePerseusGraphTypeLinearSystem = object({
  type: constant("linear-system"),
  // TODO(benchristel): default coords to empty array?
  coords: optional(nullable(array(pair(pairOfNumbers, pairOfNumbers)))),
  startCoords: optional(array(pair(pairOfNumbers, pairOfNumbers))),
  // TODO: remove coord? it's legacy.
  coord: optional(pairOfNumbers)
});
const parsePerseusGraphTypeNone = object({
  type: constant("none")
});
const parsePerseusGraphTypePoint = object({
  type: constant("point"),
  numPoints: optional(union(number).or(constant("unlimited")).parser),
  coords: optional(nullable(array(pairOfNumbers))),
  startCoords: optional(array(pairOfNumbers)),
  // TODO: remove coord? it's legacy.
  coord: optional(pairOfNumbers)
});
const parsePerseusGraphTypePolygon = object({
  type: constant("polygon"),
  numSides: optional(union(number).or(constant("unlimited")).parser),
  showAngles: optional(boolean),
  showSides: optional(boolean),
  snapTo: optional(enumeration("grid", "angles", "sides")),
  match: optional(enumeration("similar", "congruent", "approx", "exact")),
  startCoords: optional(array(pairOfNumbers)),
  // TODO: remove coord? it's legacy.
  coord: optional(pairOfNumbers)
});
const parsePerseusGraphTypeQuadratic = object({
  type: constant("quadratic"),
  coords: optional(nullable(trio(pairOfNumbers, pairOfNumbers, pairOfNumbers))),
  startCoords: optional(trio(pairOfNumbers, pairOfNumbers, pairOfNumbers)),
  // TODO: remove coord? it's legacy.
  coord: optional(pairOfNumbers)
});
const parsePerseusGraphTypeRay = object({
  type: constant("ray"),
  coords: optional(nullable(pair(pairOfNumbers, pairOfNumbers))),
  startCoords: optional(pair(pairOfNumbers, pairOfNumbers)),
  // TODO: remove coord? it's legacy.
  coord: optional(pairOfNumbers)
});
const parsePerseusGraphTypeSegment = object({
  type: constant("segment"),
  // TODO(benchristel): default numSegments?
  numSegments: optional(number),
  coords: optional(nullable(array(pair(pairOfNumbers, pairOfNumbers)))),
  startCoords: optional(array(pair(pairOfNumbers, pairOfNumbers))),
  // TODO: remove coord? it's legacy.
  coord: optional(pairOfNumbers)
});
const parsePerseusGraphTypeSinusoid = object({
  type: constant("sinusoid"),
  coords: optional(nullable(array(pairOfNumbers))),
  startCoords: optional(array(pairOfNumbers)),
  // TODO: remove coord? it's legacy.
  coord: optional(pairOfNumbers)
});
const parsePerseusGraphType = discriminatedUnionOn("type").withBranch("angle", parsePerseusGraphTypeAngle).withBranch("circle", parsePerseusGraphTypeCircle).withBranch("linear", parsePerseusGraphTypeLinear).withBranch("linear-system", parsePerseusGraphTypeLinearSystem).withBranch("none", parsePerseusGraphTypeNone).withBranch("point", parsePerseusGraphTypePoint).withBranch("polygon", parsePerseusGraphTypePolygon).withBranch("quadratic", parsePerseusGraphTypeQuadratic).withBranch("ray", parsePerseusGraphTypeRay).withBranch("segment", parsePerseusGraphTypeSegment).withBranch("sinusoid", parsePerseusGraphTypeSinusoid).parser;
const parseLockedFigureColor = enumeration(...lockedFigureColorNames);
const parseLockedFigureFillType = enumeration("none", "white", "translucent", "solid");
const parseLockedLineStyle = enumeration("solid", "dashed");
const parseLockedLabelType = object({
  type: constant("label"),
  coord: pairOfNumbers,
  text: string,
  color: parseLockedFigureColor,
  size: enumeration("small", "medium", "large")
});
const parseLockedPointType = object({
  type: constant("point"),
  coord: pairOfNumbers,
  color: parseLockedFigureColor,
  filled: boolean,
  // TODO(benchristel): default labels to empty array?
  labels: optional(array(parseLockedLabelType)),
  ariaLabel: optional(string)
});
const parseLockedLineType = object({
  type: constant("line"),
  kind: enumeration("line", "ray", "segment"),
  points: pair(parseLockedPointType, parseLockedPointType),
  color: parseLockedFigureColor,
  lineStyle: parseLockedLineStyle,
  showPoint1: defaulted(boolean, () => false),
  showPoint2: defaulted(boolean, () => false),
  // TODO(benchristel): default labels to empty array?
  labels: optional(array(parseLockedLabelType)),
  ariaLabel: optional(string)
});
const parseLockedVectorType = object({
  type: constant("vector"),
  points: pair(pairOfNumbers, pairOfNumbers),
  color: parseLockedFigureColor,
  // TODO(benchristel): default labels to empty array?
  labels: optional(array(parseLockedLabelType)),
  ariaLabel: optional(string)
});
const parseLockedEllipseType = object({
  type: constant("ellipse"),
  center: pairOfNumbers,
  radius: pairOfNumbers,
  angle: number,
  color: parseLockedFigureColor,
  fillStyle: parseLockedFigureFillType,
  strokeStyle: parseLockedLineStyle,
  // TODO(benchristel): default labels to empty array?
  labels: optional(array(parseLockedLabelType)),
  ariaLabel: optional(string)
});
const parseLockedPolygonType = object({
  type: constant("polygon"),
  points: array(pairOfNumbers),
  color: parseLockedFigureColor,
  showVertices: boolean,
  fillStyle: parseLockedFigureFillType,
  strokeStyle: parseLockedLineStyle,
  // TODO(benchristel): default labels to empty array?
  labels: optional(array(parseLockedLabelType)),
  ariaLabel: optional(string)
});
const parseLockedFunctionType = object({
  type: constant("function"),
  color: parseLockedFigureColor,
  strokeStyle: parseLockedLineStyle,
  equation: string,
  directionalAxis: enumeration("x", "y"),
  domain: optional(pairOfNumbers),
  // TODO(benchristel): default labels to empty array?
  labels: optional(array(parseLockedLabelType)),
  ariaLabel: optional(string)
});
const parseLockedFigure = discriminatedUnionOn("type").withBranch("point", parseLockedPointType).withBranch("line", parseLockedLineType).withBranch("vector", parseLockedVectorType).withBranch("ellipse", parseLockedEllipseType).withBranch("polygon", parseLockedPolygonType).withBranch("function", parseLockedFunctionType).withBranch("label", parseLockedLabelType).parser;
const parseInteractiveGraphWidget = parseWidget(constant("interactive-graph"), object({
  step: pairOfNumbers,
  // TODO(benchristel): rather than making gridStep and snapStep
  // optional, we should duplicate the defaulting logic from the
  // InteractiveGraph component. See parse-perseus-json/README.md for
  // why.
  gridStep: optional(pairOfNumbers),
  snapStep: optional(pairOfNumbers),
  backgroundImage: optional(parsePerseusImageBackground),
  markings: enumeration("graph", "grid", "none"),
  labels: optional(array(string)),
  showProtractor: boolean,
  showRuler: optional(boolean),
  showTooltips: optional(boolean),
  rulerLabel: optional(string),
  rulerTicks: optional(number),
  range: pair(pairOfNumbers, pairOfNumbers),
  // NOTE(benchristel): I copied the default graph from
  // interactive-graph.tsx. See the parse-perseus-json/README.md for
  // an explanation of why we want to duplicate the default here.
  graph: defaulted(parsePerseusGraphType, () => ({
    type: "linear"
  })),
  correct: parsePerseusGraphType,
  // TODO(benchristel): default lockedFigures to empty array
  lockedFigures: optional(array(parseLockedFigure)),
  fullGraphLabel: optional(string),
  fullGraphAriaDescription: optional(string)
}));

const parseLabelImageWidget = parseWidget(constant("label-image"), object({
  choices: array(string),
  imageUrl: string,
  imageAlt: string,
  imageHeight: number,
  imageWidth: number,
  markers: array(object({
    answers: array(string),
    label: string,
    x: number,
    y: number
  })),
  hideChoicesFromInstructions: boolean,
  multipleAnswers: boolean,
  static: defaulted(boolean, () => false)
}));

const parseMatcherWidget = parseWidget(constant("matcher"), object({
  labels: array(string),
  left: array(string),
  right: array(string),
  orderMatters: boolean,
  padding: boolean
}));

const numberOrString = union(number).or(string).parser;
const numeric = pipeParsers(defaulted(numberOrString, () => NaN)).then(stringToNumber).parser;
const parseMatrixWidget = parseWidget(defaulted(constant("matrix"), () => "matrix"), object({
  prefix: optional(string),
  suffix: optional(string),
  answers: array(array(numeric)),
  cursorPosition: optional(array(number)),
  matrixBoardSize: array(number),
  static: optional(boolean)
}));

const parseMeasurerWidget = parseWidget(constant("measurer"), object({
  // The default value for image comes from measurer.tsx.
  // See parse-perseus-json/README.md for why we want to duplicate the
  // defaults here.
  image: defaulted(parsePerseusImageBackground, () => ({
    url: null,
    top: 0,
    left: 0
  })),
  showProtractor: boolean,
  showRuler: boolean,
  rulerLabel: string,
  rulerTicks: number,
  rulerPixels: number,
  rulerLength: number,
  box: pair(number, number),
  // TODO(benchristel): static is not used. Remove it?
  static: defaulted(boolean, () => false)
}));

const parseMoleculeRendererWidget = parseWidget(constant("molecule-renderer"), object({
  widgetId: string,
  rotationAngle: optional(number),
  smiles: optional(string)
}));

const emptyStringToNull = pipeParsers(constant("")).then(convert(() => null)).parser;
const parseNumberLineWidget = parseWidget(constant("number-line"), object({
  range: array(number),
  labelRange: array(nullable(union(number).or(emptyStringToNull).parser)),
  labelStyle: string,
  labelTicks: boolean,
  isTickCtrl: optional(nullable(boolean)),
  divisionRange: array(number),
  numDivisions: optional(nullable(number)),
  // NOTE(benchristel): I copied the default snapDivisions from
  // number-line.tsx. See the parse-perseus-json/README.md for
  // an explanation of why we want to duplicate the default here.
  snapDivisions: defaulted(number, () => 2),
  tickStep: optional(nullable(number)),
  correctRel: optional(nullable(string)),
  correctX: nullable(number),
  initialX: optional(nullable(number)),
  showTooltips: optional(boolean),
  static: defaulted(boolean, () => false)
}));

const parseMathFormat = enumeration("integer", "mixed", "improper", "proper", "decimal", "percent", "pi");
const parseNumericInputWidget = parseWidget(constant("numeric-input"), object({
  answers: array(object({
    message: string,
    // TODO(benchristel): value should never be null or undefined,
    // but we have some content where it is anyway. If we backfill
    // the data, simplify this.
    value: optional(nullable(number)),
    status: string,
    answerForms: defaulted(array(parseMathFormat), () => undefined),
    strict: boolean,
    maxError: optional(nullable(number)),
    // TODO(benchristel): simplify should never be a boolean, but we
    // have some content where it is anyway. If we ever backfill
    // the data, we should simplify `simplify`.
    simplify: optional(nullable(union(string).or(pipeParsers(boolean).then(convert(String)).parser).parser))
  })),
  labelText: optional(string),
  size: string,
  coefficient: defaulted(boolean, () => false),
  rightAlign: optional(boolean),
  static: defaulted(boolean, () => false),
  answerForms: optional(array(object({
    name: parseMathFormat,
    simplify: optional(nullable(enumeration("required", "correct", "enforced", "optional")))
  })))
}));

// There is an import cycle between orderer-widget.ts and perseus-renderer.ts.
// This wrapper ensures that we don't refer to parsePerseusRenderer before
// it's defined.
function parseRenderer(rawValue, ctx) {
  return parsePerseusRenderer(rawValue, ctx);
}
const largeToAuto = (height, ctx) => {
  if (height === "large") {
    return ctx.success("auto");
  }
  return ctx.success(height);
};
const parseOrdererWidget = parseWidget(constant("orderer"), object({
  options: defaulted(array(parseRenderer), () => []),
  correctOptions: array(parseRenderer),
  otherOptions: array(parseRenderer),
  height: pipeParsers(enumeration("normal", "auto", "large")).then(largeToAuto).parser,
  layout: defaulted(enumeration("horizontal", "vertical"), () => "horizontal")
}));

const parsePassageRefWidget = parseWidget(constant("passage-ref"), object({
  passageNumber: number,
  referenceNumber: number,
  summaryText: optional(string)
}));

const parsePassageWidget = parseWidget(constant("passage"), object({
  footnotes: defaulted(string, () => ""),
  passageText: string,
  passageTitle: defaulted(string, () => ""),
  showLineNumbers: boolean,
  static: defaulted(boolean, () => false)
}));

const parsePhetSimulationWidget = parseWidget(constant("phet-simulation"), object({
  url: string,
  description: string
}));

const parsePlotterWidget = parseWidget(constant("plotter"), object({
  labels: array(string),
  categories: array(string),
  type: enumeration(...plotterPlotTypes),
  maxY: number,
  // The default value for scaleY comes from plotter.tsx.
  // See parse-perseus-json/README.md for why we want to duplicate the
  // defaults here.
  scaleY: defaulted(number, () => 1),
  labelInterval: optional(nullable(number)),
  // The default value for snapsPerLine comes from plotter.tsx.
  // See parse-perseus-json/README.md for why we want to duplicate the
  // defaults here.
  snapsPerLine: defaulted(number, () => 2),
  starting: array(number),
  correct: array(number),
  picUrl: optional(nullable(string)),
  picSize: optional(nullable(number)),
  picBoxHeight: optional(nullable(number)),
  // NOTE(benchristel): I copied the default plotDimensions from
  // plotter.tsx. See the parse-perseus-json/README.md for an explanation
  // of why we want to duplicate the defaults here.
  plotDimensions: defaulted(array(number), () => [380, 300])
}));

const parsePythonProgramWidget = parseWidget(constant("python-program"), object({
  programID: string,
  height: number
}));

const parseRadioWidget = parseWidget(constant("radio"), object({
  choices: array(object({
    content: defaulted(string, () => ""),
    clue: optional(string),
    correct: optional(boolean),
    isNoneOfTheAbove: optional(boolean),
    // deprecated
    // There is an import cycle between radio-widget.ts and
    // widgets-map.ts. The anonymous function below ensures that we
    // don't refer to parseWidgetsMap before it's defined.
    widgets: defaulted((rawVal, ctx) => parseWidgetsMap(rawVal, ctx), () => undefined)
  })),
  hasNoneOfTheAbove: optional(boolean),
  countChoices: optional(boolean),
  randomize: optional(boolean),
  multipleSelect: optional(boolean),
  deselectEnabled: optional(boolean),
  // deprecated
  onePerLine: optional(boolean),
  // deprecated
  displayCount: optional(any),
  // v0 props
  // `noneOfTheAbove` is still in use (but only set to `false`).
  noneOfTheAbove: optional(constant(false))
}));

const parseSorterWidget = parseWidget(constant("sorter"), object({
  correct: array(string),
  padding: boolean,
  layout: enumeration("horizontal", "vertical")
}));

const parseTableWidget = parseWidget(constant("table"), object({
  headers: array(string),
  rows: number,
  columns: number,
  answers: array(array(string))
}));

const parseVideoWidget = parseWidget(constant("video"), object({
  location: string,
  static: optional(boolean)
}));

const parseWidgetsMap = (rawValue, ctx) => {
  if (!isObject(rawValue)) {
    return ctx.failure("PerseusWidgetsMap", rawValue);
  }
  const widgetsMap = {};
  for (const key of Object.keys(rawValue)) {
    // parseWidgetsMapEntry modifies the widgetsMap. This is kind of gross,
    // but it's the only way I could find to make TypeScript check the key
    // against the widget type.
    const entryResult = parseWidgetsMapEntry([key, rawValue[key]], widgetsMap, ctx.forSubtree(key));
    if (isFailure(entryResult)) {
      return entryResult;
    }
  }
  return ctx.success(widgetsMap);
};
const parseWidgetsMapEntry = ([id, widget], widgetMap, ctx) => {
  const idComponentsResult = parseWidgetIdComponents(id.split(" "), ctx.forSubtree("(widget ID)"));
  if (isFailure(idComponentsResult)) {
    return idComponentsResult;
  }
  const [type, n] = idComponentsResult.value;
  function parseAndAssign(key, parse) {
    const widgetResult = parse(widget, ctx);
    if (isFailure(widgetResult)) {
      return widgetResult;
    }
    widgetMap[key] = widgetResult.value;
    return ctx.success(undefined);
  }
  switch (type) {
    case "categorizer":
      return parseAndAssign(`categorizer ${n}`, parseCategorizerWidget);
    case "cs-program":
      return parseAndAssign(`cs-program ${n}`, parseCSProgramWidget);
    case "definition":
      return parseAndAssign(`definition ${n}`, parseDefinitionWidget);
    case "dropdown":
      return parseAndAssign(`dropdown ${n}`, parseDropdownWidget);
    case "explanation":
      return parseAndAssign(`explanation ${n}`, parseExplanationWidget);
    case "expression":
      return parseAndAssign(`expression ${n}`, parseExpressionWidget);
    case "grapher":
      return parseAndAssign(`grapher ${n}`, parseGrapherWidget);
    case "group":
      return parseAndAssign(`group ${n}`, parseGroupWidget);
    case "graded-group":
      return parseAndAssign(`graded-group ${n}`, parseGradedGroupWidget);
    case "graded-group-set":
      return parseAndAssign(`graded-group-set ${n}`, parseGradedGroupSetWidget);
    case "iframe":
      return parseAndAssign(`iframe ${n}`, parseIframeWidget);
    case "image":
      return parseAndAssign(`image ${n}`, parseImageWidget);
    case "input-number":
      return parseAndAssign(`input-number ${n}`, parseInputNumberWidget);
    case "interaction":
      return parseAndAssign(`interaction ${n}`, parseInteractionWidget);
    case "interactive-graph":
      return parseAndAssign(`interactive-graph ${n}`, parseInteractiveGraphWidget);
    case "label-image":
      return parseAndAssign(`label-image ${n}`, parseLabelImageWidget);
    case "matcher":
      return parseAndAssign(`matcher ${n}`, parseMatcherWidget);
    case "matrix":
      return parseAndAssign(`matrix ${n}`, parseMatrixWidget);
    case "measurer":
      return parseAndAssign(`measurer ${n}`, parseMeasurerWidget);
    case "molecule-renderer":
      return parseAndAssign(`molecule-renderer ${n}`, parseMoleculeRendererWidget);
    case "number-line":
      return parseAndAssign(`number-line ${n}`, parseNumberLineWidget);
    case "numeric-input":
      return parseAndAssign(`numeric-input ${n}`, parseNumericInputWidget);
    case "orderer":
      return parseAndAssign(`orderer ${n}`, parseOrdererWidget);
    case "passage":
      return parseAndAssign(`passage ${n}`, parsePassageWidget);
    case "passage-ref":
      return parseAndAssign(`passage-ref ${n}`, parsePassageRefWidget);
    case "passage-ref-target":
      // NOTE(benchristel): as of 2024-11-12, passage-ref-target is only
      // used in test content. See:
      // https://www.khanacademy.org/devadmin/content/search?query=widget:passage-ref-target
      return parseAndAssign(`passage-ref-target ${n}`, any);
    case "phet-simulation":
      return parseAndAssign(`phet-simulation ${n}`, parsePhetSimulationWidget);
    case "plotter":
      return parseAndAssign(`plotter ${n}`, parsePlotterWidget);
    case "python-program":
      return parseAndAssign(`python-program ${n}`, parsePythonProgramWidget);
    case "radio":
      return parseAndAssign(`radio ${n}`, parseRadioWidget);
    case "sorter":
      return parseAndAssign(`sorter ${n}`, parseSorterWidget);
    case "table":
      return parseAndAssign(`table ${n}`, parseTableWidget);
    case "video":
      return parseAndAssign(`video ${n}`, parseVideoWidget);
    case "sequence":
      // sequence is a deprecated widget type, and the corresponding
      // widget component no longer exists.
      return parseAndAssign(`sequence ${n}`, parseDeprecatedWidget);
    case "lights-puzzle":
      return parseAndAssign(`lights-puzzle ${n}`, parseDeprecatedWidget);
    case "simulator":
      return parseAndAssign(`simulator ${n}`, parseDeprecatedWidget);
    case "transformer":
      return parseAndAssign(`transformer ${n}`, parseDeprecatedWidget);
    default:
      return parseAndAssign(`${type} ${n}`, parseWidget(constant(type), any));
  }
};
const parseDeprecatedWidget = parseWidget(
// Ignore the incoming widget type and hardcode "deprecated-standin"
(_, ctx) => ctx.success("deprecated-standin"),
// Allow any widget options
object({}));
const parseStringToNonNegativeInt = (rawValue, ctx) => {
  // The article renderer seems to allow the numeric part of a widget ID to
  // be 0, at least for image widgets. However, if widget IDs in an exercise
  // contain 0, the exercise renderer will blow up. We allow 0 here for
  // compatibility with articles.
  if (typeof rawValue !== "string" || !/^(0|[1-9][0-9]*)$/.test(rawValue)) {
    return ctx.failure("a string representing a non-negative integer", rawValue);
  }
  return ctx.success(+rawValue);
};
const parseWidgetIdComponents = pair(string, parseStringToNonNegativeInt);

const parsePerseusRenderer = defaulted(object({
  // TODO(benchristel): content is also defaulted to empty string in
  // renderer.tsx. See if we can remove one default or the other.
  content: defaulted(string, () => ""),
  // This module has an import cycle with parseWidgetsMap, because the
  // `group` widget can contain another renderer.
  // The anonymous function below ensures that we don't try to access
  // parseWidgetsMap before it's defined.
  widgets: defaulted((rawVal, ctx) => parseWidgetsMap(rawVal, ctx), () => ({})),
  images: parseImages,
  // deprecated
  metadata: any
}),
// Default value
() => ({
  content: "",
  widgets: {},
  images: {}
}));

const parsePerseusArticle = union(parsePerseusRenderer).or(array(parsePerseusRenderer)).parser;

const parseHint = object({
  replace: optional(boolean),
  content: string,
  widgets: defaulted(parseWidgetsMap, () => ({})),
  images: parseImages,
  // deprecated
  metadata: any
});

const parsePerseusAnswerArea = pipeParsers(defaulted(object({}), () => ({}))).then(convert(toAnswerArea)).parser;

// Some answerAreas have extra, bogus fields, like:
//
//   "answerArea": {
//     "type": "multiple",
//     "options": {},
//     "version": null,
//     "static": false,
//     "graded": false,
//     "alignment": "",
//   }
//
// This function filters the fields of an answerArea object, keeping only the
// known ones, and converts `undefined` and `null` values to `false`.
function toAnswerArea(raw) {
  return {
    zTable: !!raw.zTable,
    calculator: !!raw.calculator,
    chi2Table: !!raw.chi2Table,
    financialCalculatorMonthlyPayment: !!raw.financialCalculatorMonthlyPayment,
    financialCalculatorTotalAmount: !!raw.financialCalculatorTotalAmount,
    financialCalculatorTimeToPayOff: !!raw.financialCalculatorTimeToPayOff,
    periodicTable: !!raw.periodicTable,
    periodicTableWithKey: !!raw.periodicTableWithKey,
    tTable: !!raw.tTable
  };
}

const parsePerseusItem$1 = object({
  question: parsePerseusRenderer,
  hints: defaulted(array(parseHint), () => []),
  answerArea: parsePerseusAnswerArea,
  itemDataVersion: optional(object({
    major: number,
    minor: number
  })),
  // Deprecated field
  answer: any
});

/**
 * Helper to parse PerseusItem JSON
 * Why not just use JSON.parse? We want:
 * - To make sure types are correct
 * - To give us a central place to validate/transform output if needed
 * @deprecated - use parseAndMigratePerseusItem instead
 * @param {string} json - the stringified PerseusItem JSON
 * @returns {PerseusItem} the parsed PerseusItem object
 */
function parsePerseusItem(json) {
  // Try to block a cheating vector which relies on monkey-patching
  // JSON.parse
  if (isRealJSONParse(JSON.parse)) {
    return JSON.parse(json);
  }
  throw new Error("Something went wrong.");
}
/**
 * Parses a PerseusItem from a JSON string, migrates old formats to the latest
 * schema, and runtime-typechecks the result. Use this to parse assessmentItem
 * data.
 *
 * @returns a {@link Result} of the parsed PerseusItem. If the result is a
 * failure, it will contain an error message describing where in the tree
 * parsing failed.
 * @throws SyntaxError if the argument is not well-formed JSON.
 */
function parseAndMigratePerseusItem(json) {
  throwErrorIfCheatingDetected();
  const object = JSON.parse(json);
  const result = parse(object, parsePerseusItem$1);
  if (isFailure(result)) {
    return failure({
      message: result.detail,
      invalidObject: object
    });
  }
  return result;
}

/**
 * Parses a PerseusArticle from a JSON string, migrates old formats to the
 * latest schema, and runtime-typechecks the result.
 *
 * @returns a {@link Result} of the parsed PerseusArticle. If the result is a
 * failure, it will contain an error message describing where in the tree
 * parsing failed.
 * @throws SyntaxError if the argument is not well-formed JSON.
 */
function parseAndMigratePerseusArticle(json) {
  throwErrorIfCheatingDetected();
  const object = JSON.parse(json);
  const result = parse(object, parsePerseusArticle);
  if (isFailure(result)) {
    return failure({
      message: result.detail,
      invalidObject: object
    });
  }
  return result;
}

/**
 * Tries to block a cheating vector that relies on monkey-patching JSON.parse.
 */
// TODO(LEMS-2331): delete this function once server-side scoring is done.
function throwErrorIfCheatingDetected() {
  if (!isRealJSONParse(JSON.parse)) {
    throw new Error("Something went wrong.");
  }
}

// This file is processed by a Rollup plugin (replace) to inject the production
const libName = "@khanacademy/perseus-core";
const libVersion = "3.7.0";
addLibraryVersionToPerseusDebug(libName, libVersion);

/**
 * @typedef {Object} Errors utility for referencing the Perseus error taxonomy.
 */
const Errors = Object.freeze({
  /**
   * @property {ErrorKind} Unknown The kind of error is not known.
   */
  Unknown: "Unknown",
  /**
   * @property {ErrorKind} Internal The error is internal to the executing code.
   */
  Internal: "Internal",
  /**
   * @property {ErrorKind} InvalidInput There was a problem with the provided
   * input, such as the wrong format or a null value.
   */
  InvalidInput: "InvalidInput",
  /**
   * @property {ErrorKind} NotAllowed There was a problem due to the state of
   * the system not matching the requested operation or input. For example,
   * trying to create a username that is valid, but is already taken by
   * another user. Use {@link InvalidInput} instead when the input isn't
   * valid regardless of the state of the system. Use {@link NotFound} when
   * the failure is due to not being able to find a resource.
   */
  NotAllowed: "NotAllowed",
  /**
   * @property {ErrorKind} TransientService There was a problem when making a
   * request to a service.
   */
  TransientService: "TransientService",
  /**
   * @property {ErrorKind} Service There was a non-transient problem when
   * making a request to service.
   */
  Service: "Service"
});

/**
 * @type {ErrorKind} The kind of error being reported
 */

class PerseusError extends Error {
  constructor(message, kind, options) {
    super(message);
    this.kind = void 0;
    this.metadata = void 0;
    this.kind = kind;
    this.metadata = options == null ? void 0 : options.metadata;
  }
}

/**
 * _ utilities for objects
 */

/**
 * Does a pluck on keys inside objects in an object
 *
 * Ex:
 * tools = {
 *     translation: {
 *         enabled: true
 *     },
 *     rotation: {
 *         enabled: false
 *     }
 * };
 * pluckObject(tools, "enabled") returns {
 *     translation: true
 *     rotation: false
 * }
 */
const pluck = function pluck(table, subKey) {
  return _.object(_.map(table, function (value, key) {
    return [key, value[subKey]];
  }));
};

/**
 * Maps an object to an object
 *
 * > mapObject({a: '1', b: '2'}, (value, key) => {
 *       return value + 1;
 *   });
 * {a: 2, b: 3}
 */
const mapObject = function mapObject(obj, lambda) {
  const result = {};
  Object.keys(obj).forEach(key => {
    // @ts-expect-error - TS2345 - Argument of type 'string' is not assignable to parameter of type 'K'.
    result[key] = lambda(obj[key], key);
  });
  return result;
};

/**
 * For details on the individual options, see the
 * PerseusCategorizerWidgetOptions type
 */

/**
 * Given a PerseusCategorizerWidgetOptions object, return a new object with only
 * the public options that should be exposed to the client.
 */
function getCategorizerPublicWidgetOptions(options) {
  return {
    items: options.items,
    categories: options.categories,
    randomizeItems: options.randomizeItems,
    static: options.static
  };
}

const defaultWidgetOptions$v = {
  items: [],
  categories: [],
  values: [],
  randomizeItems: false
};
const categorizerWidgetLogic = {
  name: "categorizer",
  defaultWidgetOptions: defaultWidgetOptions$v,
  getPublicWidgetOptions: getCategorizerPublicWidgetOptions
};

function getCSProgramPublicWidgetOptions(options) {
  return options;
}

const DEFAULT_HEIGHT = 400;
const defaultWidgetOptions$u = {
  programID: "",
  programType: null,
  settings: [{
    name: "",
    value: ""
  }],
  showEditor: false,
  showButtons: false,
  height: DEFAULT_HEIGHT
};
const csProgramWidgetLogic = {
  name: "cs-program",
  defaultWidgetOptions: defaultWidgetOptions$u,
  supportedAlignments: ["block", "full-width"],
  getPublicWidgetOptions: getCSProgramPublicWidgetOptions
};

const defaultWidgetOptions$t = {
  togglePrompt: "",
  definition: ""
};
const definitionWidgetLogic = {
  name: "definition",
  defaultWidgetOptions: defaultWidgetOptions$t,
  defaultAlignment: "inline"
};

/**
 * For details on the individual options, see the
 * PerseusDropdownWidgetOptions type
 */

/**
 * Given a PerseusDropdownWidgetOptions object, return a new object with only
 * the public options that should be exposed to the client.
 */
function getDropdownPublicWidgetOptions(options) {
  return {
    choices: options.choices.map(choice => ({
      content: choice.content
    })),
    placeholder: options.placeholder,
    static: options.static,
    visibleLabel: options.visibleLabel,
    ariaLabel: options.ariaLabel
  };
}

const defaultWidgetOptions$s = {
  placeholder: "",
  choices: [{
    content: "",
    correct: false
  }]
};
const dropdownWidgetLogic = {
  name: "definition",
  defaultWidgetOptions: defaultWidgetOptions$s,
  defaultAlignment: "inline-block",
  getPublicWidgetOptions: getDropdownPublicWidgetOptions
};

const defaultWidgetOptions$r = {
  showPrompt: "Explain",
  hidePrompt: "Hide explanation",
  explanation: "explanation goes here\n\nmore explanation",
  widgets: {}
};
const explanationWidgetLogic = {
  name: "explanation",
  defaultWidgetOptions: defaultWidgetOptions$r,
  defaultAlignment: "inline"
};

const currentVersion$3 = {
  major: 1,
  minor: 0
};
const widgetOptionsUpgrades$2 = {
  "1": v0options => ({
    times: v0options.times,
    buttonSets: v0options.buttonSets,
    functions: v0options.functions,
    buttonsVisible: v0options.buttonsVisible,
    visibleLabel: v0options.visibleLabel,
    ariaLabel: v0options.ariaLabel,
    answerForms: [{
      considered: "correct",
      form: v0options.form,
      simplify: v0options.simplify,
      value: v0options.value
    }]
  })
};
const defaultWidgetOptions$q = {
  answerForms: [],
  times: false,
  buttonSets: ["basic"],
  functions: ["f", "g", "h"]
};

/**
 * For details on the individual options, see the
 * PerseusExpressionWidgetOptions type
 */

/**
 * Given a PerseusExpressionWidgetOptions object, return a new object with only
 * the public options that should be exposed to the client.
 */
function getExpressionPublicWidgetOptions(options) {
  return {
    buttonSets: options.buttonSets,
    functions: options.functions,
    times: options.times,
    visibleLabel: options.visibleLabel,
    ariaLabel: options.ariaLabel,
    buttonsVisible: options.buttonsVisible
  };
}

const expressionWidgetLogic = {
  name: "expression",
  version: currentVersion$3,
  widgetOptionsUpgrades: widgetOptionsUpgrades$2,
  defaultWidgetOptions: defaultWidgetOptions$q,
  defaultAlignment: "inline-block",
  getPublicWidgetOptions: getExpressionPublicWidgetOptions
};

const defaultWidgetOptions$p = {
  title: "",
  content: "",
  widgets: {},
  images: {},
  hint: null
};
const gradedGroupWidgetLogic = {
  name: "graded-group",
  defaultWidgetOptions: defaultWidgetOptions$p
};

const defaultWidgetOptions$o = {
  gradedGroups: []
};
const gradedGroupSetWidgetLogic = {
  name: "graded-group-set",
  defaultWidgetOptions: defaultWidgetOptions$o
};

function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}

const _excluded$9 = ["correct"];
function getGrapherPublicWidgetOptions(options) {
  const publicOptions = _objectWithoutPropertiesLoose(options, _excluded$9);
  return publicOptions;
}

const defaultWidgetOptions$n = {
  graph: {
    labels: ["x", "y"],
    range: [[-10, 10], [-10, 10]],
    step: [1, 1],
    backgroundImage: {
      url: null
    },
    markings: "graph",
    rulerLabel: "",
    rulerTicks: 10,
    valid: true,
    showTooltips: false
  },
  correct: {
    type: "linear",
    coords: null
  },
  availableTypes: ["linear"]
};
const grapherWidgetLogic = {
  name: "grapher",
  defaultWidgetOptions: defaultWidgetOptions$n,
  getPublicWidgetOptions: getGrapherPublicWidgetOptions
};

const defaultWidgetOptions$m = {
  content: "",
  widgets: {},
  images: {}
};
const groupWidgetLogic = {
  name: "group",
  defaultWidgetOptions: defaultWidgetOptions$m
};

function getIFramePublicWidgetOptions(options) {
  return options;
}

const defaultWidgetOptions$l = {
  url: "",
  settings: [{
    name: "",
    value: ""
  }],
  width: "400",
  height: "400",
  allowFullScreen: false,
  allowTopNavigation: false
};
const iframeWidgetLogic = {
  name: "iframe",
  defaultWidgetOptions: defaultWidgetOptions$l,
  getPublicWidgetOptions: getIFramePublicWidgetOptions
};

const defaultWidgetOptions$k = {
  title: "",
  range: [[0, 10], [0, 10]],
  box: [400, 400],
  backgroundImage: {
    url: null,
    width: 0,
    height: 0
  },
  labels: [],
  alt: "",
  caption: ""
};
const imageWidgetLogic = {
  name: "image",
  defaultWidgetOptions: defaultWidgetOptions$k,
  supportedAlignments: ["block", "full-width"],
  defaultAlignment: "block"
};

const defaultWidgetOptions$j = {
  value: 0,
  simplify: "required",
  size: "normal",
  inexact: false,
  maxError: 0.1,
  answerType: "number",
  rightAlign: false
};
const inputNumberWidgetLogic = {
  name: "input-number",
  defaultWidgetOptions: defaultWidgetOptions$j,
  defaultAlignment: "inline-block"
};

const defaultWidgetOptions$i = {
  graph: {
    box: [400, 400],
    labels: ["x", "y"],
    range: [[-10, 10], [-10, 10]],
    tickStep: [1, 1],
    gridStep: [1, 1],
    markings: "graph"
  },
  elements: []
};
const interactionWidgetLogic = {
  name: "interaction",
  defaultWidgetOptions: defaultWidgetOptions$i
};

const _excluded$8 = ["correct"];
function getInteractiveGraphPublicWidgetOptions(options) {
  const publicOptions = _objectWithoutPropertiesLoose(options, _excluded$8);
  return publicOptions;
}

const defaultWidgetOptions$h = {
  labels: ["x", "y"],
  range: [[-10, 10], [-10, 10]],
  step: [1, 1],
  backgroundImage: {
    url: null
  },
  markings: "graph",
  showTooltips: false,
  showProtractor: false,
  graph: {
    type: "linear"
  },
  correct: {
    type: "linear",
    coords: null
  }
};
const interactiveGraphWidgetLogic = {
  name: "interactive-graph",
  defaultWidgetOptions: defaultWidgetOptions$h,
  getPublicWidgetOptions: getInteractiveGraphPublicWidgetOptions
};

const _excluded$7 = ["answers"];
/**
 * For details on the individual options, see the
 * PerseusLabelImageWidgetOptions type
 */

function getLabelImagePublicWidgetOptions(options) {
  return _extends({}, options, {
    markers: options.markers.map(getLabelImageMarkerPublicData)
  });
}
function getLabelImageMarkerPublicData(marker) {
  const publicData = _objectWithoutPropertiesLoose(marker, _excluded$7);
  return publicData;
}

const defaultWidgetOptions$g = {
  choices: [],
  imageAlt: "",
  imageUrl: "",
  imageWidth: 0,
  imageHeight: 0,
  markers: [],
  multipleAnswers: false,
  hideChoicesFromInstructions: false
};
const labelImageWidgetLogic = {
  name: "label-image",
  defaultWidgetOptions: defaultWidgetOptions$g,
  getPublicWidgetOptions: getLabelImagePublicWidgetOptions
};

// TODO(LEMS-2841): Should be able to remove once getPublicWidgetOptions is hooked up

// TODO(LEMS-2841): Should be able to remove once getPublicWidgetOptions is hooked up
const shuffleMatcher = props => {
  // Use the same random() function to shuffle both columns sequentially
  const rng = seededRNG$1(props.problemNum);
  let left;
  if (!props.orderMatters) {
    // If the order doesn't matter, don't shuffle the left column
    left = props.left;
  } else {
    left = shuffle$2(props.left, rng, /* ensurePermuted */true);
  }
  const right = shuffle$2(props.right, rng, /* ensurePermuted */true);
  return {
    left,
    right
  };
};

// TODO(LEMS-2841): Can shorten to shuffleMatcher after above function removed
function shuffleMatcherWithRandom(data) {
  // Use the same random() function to shuffle both columns sequentially
  let left;
  if (!data.orderMatters) {
    // If the order doesn't matter, don't shuffle the left column
    left = data.left;
  } else {
    left = shuffle$2(data.left, Math.random, /* ensurePermuted */true);
  }
  const right = shuffle$2(data.right, Math.random, /* ensurePermuted */true);
  return {
    left,
    right
  };
}

/**
 * For details on the individual options, see the
 * PerseusMatcherWidgetOptions type
 */

/**
 * Given a PerseusMatcherWidgetOptions object, return a new object with only
 * the public options that should be exposed to the client.
 */
function getMatcherPublicWidgetOptions(options) {
  const {
    left,
    right
  } = shuffleMatcherWithRandom(options);
  return _extends({}, options, {
    left: left,
    right: right
  });
}

const defaultWidgetOptions$f = {
  left: ["$x$", "$y$", "$z$"],
  right: ["$1$", "$2$", "$3$"],
  labels: ["test", "label"],
  orderMatters: false,
  padding: true
};
const matcherWidgetLogic = {
  name: "matcher",
  defaultWidgetOptions: defaultWidgetOptions$f,
  getPublicWidgetOptions: getMatcherPublicWidgetOptions
};

const _excluded$6 = ["answers"];
function getMatrixPublicWidgetOptions(options) {
  const publicOptions = _objectWithoutPropertiesLoose(options, _excluded$6);
  return publicOptions;
}

const defaultWidgetOptions$e = {
  matrixBoardSize: [3, 3],
  answers: [[]],
  prefix: "",
  suffix: "",
  cursorPosition: [0, 0]
};
const matrixWidgetLogic = {
  name: "matrix",
  defaultWidgetOptions: defaultWidgetOptions$e,
  getPublicWidgetOptions: getMatrixPublicWidgetOptions
};

const _excluded$5 = ["imageUrl", "imageTop", "imageLeft"];
const currentVersion$2 = {
  major: 1,
  minor: 0
};
const widgetOptionsUpgrades$1 = {
  "1": v0options => {
    const {
        imageUrl,
        imageTop,
        imageLeft
      } = v0options,
      rest = _objectWithoutPropertiesLoose(v0options, _excluded$5);
    return _extends({}, rest, {
      image: {
        url: imageUrl,
        top: imageTop,
        left: imageLeft
      }
    });
  }
};
const defaultWidgetOptions$d = {
  box: [480, 480],
  image: {},
  showProtractor: true,
  showRuler: false,
  rulerLabel: "",
  rulerTicks: 10,
  rulerPixels: 40,
  rulerLength: 10
};

const measurerWidgetLogic = {
  name: "measurer",
  version: currentVersion$2,
  widgetOptionsUpgrades: widgetOptionsUpgrades$1,
  defaultWidgetOptions: defaultWidgetOptions$d
};

const _excluded$4 = ["correctX", "correctRel"];
function getNumberLinePublicWidgetOptions(options) {
  const publicOptions = _objectWithoutPropertiesLoose(options, _excluded$4);
  return publicOptions;
}

const defaultWidgetOptions$c = {
  range: [0, 10],
  labelRange: [null, null],
  labelStyle: "decimal",
  labelTicks: true,
  divisionRange: [1, 12],
  numDivisions: 5,
  snapDivisions: 2,
  tickStep: null,
  correctRel: "eq",
  correctX: null,
  initialX: null,
  showTooltips: false
};
const numberLineWidgetLogic = {
  name: "number-line",
  defaultWidgetOptions: defaultWidgetOptions$c,
  getPublicWidgetOptions: getNumberLinePublicWidgetOptions
};

const _excluded$3 = ["answers"];
/**
 * For details on the individual options, see the
 * PerseusNumericInputWidgetOptions type
 */

/**
 * Given a PerseusNumericInputWidgetOptions object, return a new object with only
 * the public options that should be exposed to the client.
 */
function getNumericInputPublicWidgetOptions(options) {
  const publicWidgetOptions = _objectWithoutPropertiesLoose(options, _excluded$3);
  return publicWidgetOptions;
}

const defaultWidgetOptions$b = {
  answers: [{
    value: null,
    status: "correct",
    message: "",
    simplify: "required",
    answerForms: [],
    strict: false,
    maxError: null
  }],
  size: "normal",
  coefficient: false,
  labelText: "",
  rightAlign: false
};
const numericInputWidgetLogic = {
  name: "numeric-input",
  defaultWidgetOptions: defaultWidgetOptions$b,
  defaultAlignment: "inline-block",
  getPublicWidgetOptions: getNumericInputPublicWidgetOptions
};

/**
 * For details on the individual options, see the
 * PerseusOrdererWidgetOptions type
 */

/**
 * Given a PerseusOrdererWidgetOptions object, return a new object with only
 * the public options that should be exposed to the client.
 */
function getOrdererPublicWidgetOptions(options) {
  return {
    options: options.options,
    height: options.height,
    layout: options.layout
  };
}

const defaultWidgetOptions$a = {
  correctOptions: [{
    content: "$x$"
  }],
  otherOptions: [{
    content: "$y$"
  }],
  height: "normal",
  layout: "horizontal"
};
const ordererWidgetLogic = {
  name: "orderer",
  defaultWidgetOptions: defaultWidgetOptions$a,
  getPublicWidgetOptions: getOrdererPublicWidgetOptions
};

const defaultWidgetOptions$9 = {
  passageTitle: "",
  passageText: "",
  footnotes: "",
  showLineNumbers: true
};
const passageWidgetLogic = {
  name: "passage",
  defaultWidgetOptions: defaultWidgetOptions$9
};

const currentVersion$1 = {
  major: 0,
  minor: 1
};
const defaultWidgetOptions$8 = {
  passageNumber: 1,
  referenceNumber: 1,
  summaryText: ""
};

const passageRefWidgetLogic = {
  name: "passageRef",
  version: currentVersion$1,
  defaultWidgetOptions: defaultWidgetOptions$8,
  defaultAlignment: "inline"
};

const defaultWidgetOptions$7 = {
  content: ""
};
const passageRefTargetWidgetLogic = {
  name: "passageRefTarget",
  defaultWidgetOptions: defaultWidgetOptions$7,
  defaultAlignment: "inline"
};

const defaultWidgetOptions$6 = {
  url: "",
  description: ""
};
const phetSimulationWidgetLogic = {
  name: "phet-simulation",
  defaultWidgetOptions: defaultWidgetOptions$6
};

const _excluded$2 = ["correct"];
/**
 * For details on the individual options, see the
 * PerseusPlotterWidgetOptions type
 */

/**
 * Given a PerseusPlotterWidgetOptions object, return a new object with only
 * the public options that should be exposed to the client.
 */
function getPlotterPublicWidgetOptions(options) {
  const publicOptions = _objectWithoutPropertiesLoose(options, _excluded$2);
  return publicOptions;
}

const defaultWidgetOptions$5 = {
  scaleY: 1,
  maxY: 10,
  snapsPerLine: 2,
  correct: [1],
  starting: [1],
  type: "bar",
  labels: ["", ""],
  categories: [""],
  picSize: 30,
  picBoxHeight: 36,
  plotDimensions: [275, 200],
  labelInterval: 1,
  picUrl: null
};
const plotterWidgetLogic = {
  name: "plotter",
  defaultWidgetOptions: defaultWidgetOptions$5,
  getPublicWidgetOptions: getPlotterPublicWidgetOptions
};

const defaultWidgetOptions$4 = {
  programID: "",
  height: 400
};
const pythonProgramWidgetLogic = {
  name: "python-program",
  defaultWidgetOptions: defaultWidgetOptions$4
};

const _excluded$1 = ["noneOfTheAbove"];
const currentVersion = {
  major: 1,
  minor: 0
};
const widgetOptionsUpgrades = {
  "1": v0props => {
    const {
        noneOfTheAbove
      } = v0props,
      rest = _objectWithoutPropertiesLoose(v0props, _excluded$1);
    if (noneOfTheAbove) {
      throw new Error("radio widget v0 no longer supports auto noneOfTheAbove");
    }
    return _extends({}, rest, {
      hasNoneOfTheAbove: false
    });
  }
};
const defaultWidgetOptions$3 = {
  choices: [{}, {}, {}, {}],
  displayCount: null,
  randomize: false,
  hasNoneOfTheAbove: false,
  multipleSelect: false,
  countChoices: false,
  deselectEnabled: false
};

/**
 * For details on the individual options, see the
 * PerseusRadioWidgetOptions type
 */

/**
 * Only the options from each Radio choice that should be exposed to the client.
 */

/**
 * Given a PerseusRadioChoice object, return a new object with only the public
 * data that should be included in the Radio public widget options.
 */
function getRadioChoicePublicData(choice) {
  const {
    content,
    isNoneOfTheAbove,
    widgets
  } = choice;
  return {
    content,
    isNoneOfTheAbove,
    widgets
  };
}

/**
 * Given a PerseusRadioWidgetOptions object, return a new object with only
 * the public options that should be exposed to the client.
 */
function getRadioPublicWidgetOptions(options) {
  return _extends({}, options, {
    choices: options.choices.map(getRadioChoicePublicData)
  });
}

const radioWidgetLogic = {
  name: "radio",
  version: currentVersion,
  widgetOptionsUpgrades: widgetOptionsUpgrades,
  defaultWidgetOptions: defaultWidgetOptions$3,
  getPublicWidgetOptions: getRadioPublicWidgetOptions
};

/**
 * For details on the individual options, see the
 * PerseusSorterWidgetOptions type
 */

/**
 * Given a PerseusSorterWidgetOptions object, return a new object with only
 * the public options that should be exposed to the client.
 */
function getSorterPublicWidgetOptions(options) {
  const shuffledCorrect = shuffle$2(options.correct, Math.random, /* ensurePermuted */true);
  return _extends({}, options, {
    // Note(Tamara): This does not provide correct answer information any longer.
    // To maintain compatibility with the original widget options, we are
    // keeping the key the same. Represents initial state of the cards here.
    correct: shuffledCorrect,
    // Note(Tamara): This new key is only added here with "true". There isn't
    // a place where it is set to false. It indicates that the correct field
    // has been shuffled and no longer contains correct answer info.
    isCorrectShuffled: true
  });
}

const defaultWidgetOptions$2 = {
  correct: ["$x$", "$y$", "$z$"],
  layout: "horizontal",
  padding: true
};
const sorterWidgetLogic = {
  name: "sorter",
  defaultWidgetOptions: defaultWidgetOptions$2,
  getPublicWidgetOptions: getSorterPublicWidgetOptions
};

const _excluded = ["answers"];
function getTablePublicWidgetOptions(options) {
  const publicOptions = _objectWithoutPropertiesLoose(options, _excluded);
  return publicOptions;
}

const defaultRows = 4;
const defaultColumns = 1;

// initialize a 2D array
// (defaultRows x defaultColumns) of empty strings
const answers = new Array(defaultRows).fill(0).map(() => new Array(defaultColumns).fill(""));
const defaultWidgetOptions$1 = {
  headers: [""],
  rows: defaultRows,
  columns: defaultColumns,
  answers: answers
};
const tableWidgetLogic = {
  name: "table",
  defaultWidgetOptions: defaultWidgetOptions$1,
  getPublicWidgetOptions: getTablePublicWidgetOptions
};

const defaultWidgetOptions = {
  location: ""
};
const videoWidgetLogic = {
  name: "video",
  defaultWidgetOptions,
  supportedAlignments: ["block", "float-left", "float-right", "full-width"],
  defaultAlignment: "block"
};

const widgets = {};
function registerWidget(type, logic) {
  widgets[type] = logic;
}
function isWidgetRegistered(type) {
  const widgetLogic = widgets[type];
  return !!widgetLogic;
}
function getCurrentVersion(type) {
  const widgetLogic = widgets[type];
  return (widgetLogic == null ? void 0 : widgetLogic.version) || {
    major: 0,
    minor: 0
  };
}

// TODO(LEMS-2870): getPublicWidgetOptionsFunction/PublicWidgetOptionsFunction
// need better types
const getPublicWidgetOptionsFunction = name => {
  var _widgets$name$getPubl, _widgets$name;
  return (_widgets$name$getPubl = (_widgets$name = widgets[name]) == null ? void 0 : _widgets$name.getPublicWidgetOptions) != null ? _widgets$name$getPubl : i => i;
};
function getWidgetOptionsUpgrades(type) {
  const widgetLogic = widgets[type];
  return (widgetLogic == null ? void 0 : widgetLogic.widgetOptionsUpgrades) || {};
}
function getDefaultWidgetOptions(type) {
  const widgetLogic = widgets[type];
  return (widgetLogic == null ? void 0 : widgetLogic.defaultWidgetOptions) || {};
}

/**
 * Handling for the optional alignments for widgets
 * See widget-container.jsx for details on how alignments are implemented.
 */

/**
 * Returns the list of supported alignments for the given (string) widget
 * type. This is used primarily at editing time to display the choices
 * for the user.
 *
 * Supported alignments are given as an array of strings in the exports of
 * a widget's module.
 */
const getSupportedAlignments = type => {
  var _widgetLogic$supporte;
  const widgetLogic = widgets[type];
  if (!(widgetLogic != null && (_widgetLogic$supporte = widgetLogic.supportedAlignments) != null && _widgetLogic$supporte[0])) {
    // default alignments
    return ["default"];
  }
  return widgetLogic == null ? void 0 : widgetLogic.supportedAlignments;
};

/**
 * For the given (string) widget type, determine the default alignment for
 * the widget. This is used at rendering time to go from "default" alignment
 * to the actual alignment displayed on the screen.
 *
 * The default alignment is given either as a string (called
 * `defaultAlignment`) or a function (called `getDefaultAlignment`) on
 * the exports of a widget's module.
 */
const getDefaultAlignment = type => {
  const widgetLogic = widgets[type];
  if (!(widgetLogic != null && widgetLogic.defaultAlignment)) {
    return "block";
  }
  return widgetLogic.defaultAlignment;
};
registerWidget("categorizer", categorizerWidgetLogic);
registerWidget("cs-program", csProgramWidgetLogic);
registerWidget("definition", definitionWidgetLogic);
registerWidget("dropdown", dropdownWidgetLogic);
registerWidget("explanation", explanationWidgetLogic);
registerWidget("expression", expressionWidgetLogic);
registerWidget("graded-group", gradedGroupWidgetLogic);
registerWidget("graded-group-set", gradedGroupSetWidgetLogic);
registerWidget("grapher", grapherWidgetLogic);
registerWidget("group", groupWidgetLogic);
registerWidget("iframe", iframeWidgetLogic);
registerWidget("image", imageWidgetLogic);
registerWidget("input-number", inputNumberWidgetLogic);
registerWidget("interaction", interactionWidgetLogic);
registerWidget("interactive-graph", interactiveGraphWidgetLogic);
registerWidget("label-image", labelImageWidgetLogic);
registerWidget("matcher", matcherWidgetLogic);
registerWidget("matrix", matrixWidgetLogic);
registerWidget("measurer", measurerWidgetLogic);
registerWidget("number-line", numberLineWidgetLogic);
registerWidget("numeric-input", numericInputWidgetLogic);
registerWidget("orderer", ordererWidgetLogic);
registerWidget("passage", passageWidgetLogic);
registerWidget("passage-ref", passageRefWidgetLogic);
registerWidget("passage-ref-target", passageRefTargetWidgetLogic);
registerWidget("phet-simulation", phetSimulationWidgetLogic);
registerWidget("plotter", plotterWidgetLogic);
registerWidget("python-program", pythonProgramWidgetLogic);
registerWidget("radio", radioWidgetLogic);
registerWidget("sorter", sorterWidgetLogic);
registerWidget("table", tableWidgetLogic);
registerWidget("video", videoWidgetLogic);

var coreWidgetRegistry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    isWidgetRegistered: isWidgetRegistered,
    getCurrentVersion: getCurrentVersion,
    getPublicWidgetOptionsFunction: getPublicWidgetOptionsFunction,
    getWidgetOptionsUpgrades: getWidgetOptionsUpgrades,
    getDefaultWidgetOptions: getDefaultWidgetOptions,
    getSupportedAlignments: getSupportedAlignments,
    getDefaultAlignment: getDefaultAlignment
});

const DEFAULT_STATIC = false;
const upgradeWidgetInfoToLatestVersion = oldWidgetInfo => {
  const type = oldWidgetInfo.type;
  // NOTE(jeremy): This looks like it could be replaced by fixing types so
  // that `type` is non-optional. But we're seeing this in Sentry today so I
  // suspect we have legacy data (potentially unpublished) and we should
  // figure that out before depending solely on types.
  if (!_.isString(type)) {
    throw new PerseusError("widget type must be a string, but was: " + type, Errors.Internal);
  }
  if (!isWidgetRegistered(type)) {
    // If we have a widget that isn't registered, we can't upgrade it
    // TODO(aria): Figure out what the best thing to do here would be
    return oldWidgetInfo;
  }

  // Unversioned widgets (pre-July 2014) are all implicitly 0.0
  const initialVersion = oldWidgetInfo.version || {
    major: 0,
    minor: 0
  };
  const latestVersion = getCurrentVersion(type);

  // If the widget version is later than what we understand (major
  // version is higher than latest, or major versions are equal and minor
  // version is higher than latest), don't perform any upgrades.
  if (initialVersion.major > latestVersion.major || initialVersion.major === latestVersion.major && initialVersion.minor > latestVersion.minor) {
    return oldWidgetInfo;
  }

  // We do a clone here so that it's safe to mutate the input parameter
  // in propUpgrades functions (which I will probably accidentally do at
  // some point, and we would like to not break when that happens).
  let newEditorOptions = _.clone(oldWidgetInfo.options) || {};
  const upgradePropsMap = getWidgetOptionsUpgrades(type);

  // Empty props usually mean a newly created widget by the editor,
  // and are always considerered up-to-date.
  // Mostly, we'd rather not run upgrade functions on props that are
  // not complete.
  if (_.keys(newEditorOptions).length !== 0) {
    // We loop through all the versions after the current version of
    // the loaded widget, up to and including the latest version of the
    // loaded widget, and run the upgrade function to bring our loaded
    // widget's props up to that version.
    // There is a little subtlety here in that we call
    // upgradePropsMap[1] to upgrade *to* version 1,
    // (not from version 1).
    for (let nextVersion = initialVersion.major + 1; nextVersion <= latestVersion.major; nextVersion++) {
      if (upgradePropsMap[String(nextVersion)]) {
        newEditorOptions = upgradePropsMap[String(nextVersion)](newEditorOptions);
      } else {
        throw new PerseusError("No upgrade found for widget. Cannot render.", Errors.Internal, {
          metadata: {
            type,
            fromMajorVersion: nextVersion - 1,
            toMajorVersion: nextVersion,
            oldWidgetInfo: JSON.stringify(oldWidgetInfo)
          }
        });
      }
    }
  }

  // Minor version upgrades (eg. new optional props) don't have
  // transform functions. Instead, we fill in the new props with their
  // defaults.
  const defaultOptions = getDefaultWidgetOptions(type);
  newEditorOptions = _extends({}, defaultOptions, newEditorOptions);
  let alignment = oldWidgetInfo.alignment;

  // Widgets that support multiple alignments will "lock in" the
  // alignment to the alignment that would be listed first in the
  // select box. If the widget only supports one alignment, the
  // alignment value will likely just end up as "default".
  if (alignment == null || alignment === "default") {
    var _getSupportedAlignmen;
    alignment = (_getSupportedAlignmen = getSupportedAlignments(type)) == null ? void 0 : _getSupportedAlignmen[0];
    if (!alignment) {
      throw new PerseusError("No default alignment found when upgrading widget", Errors.Internal, {
        metadata: {
          widgetType: type
        }
      });
    }
  }
  let widgetStatic = oldWidgetInfo.static;
  if (widgetStatic == null) {
    widgetStatic = DEFAULT_STATIC;
  }
  return _extends({}, oldWidgetInfo, {
    // maintain other info, like type
    // After upgrading we guarantee that the version is up-to-date
    version: latestVersion,
    // Default graded to true (so null/undefined becomes true):
    graded: oldWidgetInfo.graded != null ? oldWidgetInfo.graded : true,
    alignment: alignment,
    static: widgetStatic,
    options: newEditorOptions
  });
};
function getUpgradedWidgetOptions(oldWidgetOptions) {
  return mapObject(oldWidgetOptions, (widgetInfo, widgetId) => {
    if (!widgetInfo.type || !widgetInfo.alignment) {
      const newValues = {};
      if (!widgetInfo.type) {
        // TODO: why does widget have no type?
        // We don't want to derive type from widget ID
        // see: LEMS-1845
        newValues.type = widgetId.split(" ")[0];
      }
      if (!widgetInfo.alignment) {
        newValues.alignment = "default";
      }
      widgetInfo = _extends({}, widgetInfo, newValues);
    }
    return upgradeWidgetInfoToLatestVersion(widgetInfo);
  });
}

function splitPerseusItem(originalItem) {
  var _item$widgets;
  const item = _.clone(originalItem);
  const originalWidgets = (_item$widgets = item.widgets) != null ? _item$widgets : {};
  const upgradedWidgets = getUpgradedWidgetOptions(originalWidgets);
  const splitWidgets = {};
  for (const [id, widget] of Object.entries(upgradedWidgets)) {
    const publicWidgetOptionsFun = getPublicWidgetOptionsFunction(widget.type);
    splitWidgets[id] = _extends({}, widget, {
      options: publicWidgetOptionsFun(widget.options)
    });
  }
  return _extends({}, item, {
    widgets: splitWidgets
  });
}

/* Note(tamara): Brought over from the perseus package packages/perseus/src/util.ts file.
    May be useful to bring other perseus package utilities here. Contains utility functions
    and types used across multiple widgets for randomization and shuffling. */
const seededRNG = function seededRNG(seed) {
  let randomSeed = seed;
  return function () {
    // Robert Jenkins' 32 bit integer hash function.
    let seed = randomSeed;
    seed = seed + 0x7ed55d16 + (seed << 12) & 0xffffffff;
    seed = (seed ^ 0xc761c23c ^ seed >>> 19) & 0xffffffff;
    seed = seed + 0x165667b1 + (seed << 5) & 0xffffffff;
    seed = (seed + 0xd3a2646c ^ seed << 9) & 0xffffffff;
    seed = seed + 0xfd7046c5 + (seed << 3) & 0xffffffff;
    seed = (seed ^ 0xb55a4f09 ^ seed >>> 16) & 0xffffffff;
    return (randomSeed = seed & 0xfffffff) / 0x10000000;
  };
};

// Shuffle an array using a given random seed or function.
// If `ensurePermuted` is true, the input and output are guaranteed to be
// distinct permutations.
function shuffle(array, randomSeed, ensurePermuted = false) {
  // Always return a copy of the input array
  const shuffled = _.clone(array);

  // Handle edge cases (input array is empty or uniform)
  if (!shuffled.length || _.all(shuffled, function (value) {
    return _.isEqual(value, shuffled[0]);
  })) {
    return shuffled;
  }
  let random;
  if (typeof randomSeed === "function") {
    random = randomSeed;
  } else {
    random = seededRNG(randomSeed);
  }
  do {
    // Fischer-Yates shuffle
    for (let top = shuffled.length; top > 0; top--) {
      const newEnd = Math.floor(random() * top);
      const temp = shuffled[newEnd];

      // @ts-expect-error - TS2542 - Index signature in type 'readonly T[]' only permits reading.
      shuffled[newEnd] = shuffled[top - 1];
      // @ts-expect-error - TS2542 - Index signature in type 'readonly T[]' only permits reading.
      shuffled[top - 1] = temp;
    }
  } while (ensurePermuted && _.isEqual(array, shuffled));
  return shuffled;
}
const random = seededRNG(new Date().getTime() & 0xffffffff);

export { coreWidgetRegistry as CoreWidgetRegistry, Errors, grapherUtil as GrapherUtil, ItemExtras, PerseusError, PerseusExpressionAnswerFormConsidered, addLibraryVersionToPerseusDebug, addWidget, approximateDeepEqual, approximateEqual, categorizerWidgetLogic as categorizerLogic, csProgramWidgetLogic as csProgramLogic, deepClone, definitionWidgetLogic as definitionLogic, dropdownWidgetLogic as dropdownLogic, explanationWidgetLogic as explanationLogic, expressionWidgetLogic as expressionLogic, getCSProgramPublicWidgetOptions, getCategorizerPublicWidgetOptions, getDecimalSeparator, getDropdownPublicWidgetOptions, getExpressionPublicWidgetOptions, getGrapherPublicWidgetOptions, getIFramePublicWidgetOptions, getInteractiveGraphPublicWidgetOptions, getLabelImagePublicWidgetOptions, getMatcherPublicWidgetOptions, getMatrixPublicWidgetOptions, getMatrixSize, getNumberLinePublicWidgetOptions, getNumericInputPublicWidgetOptions, getOrdererPublicWidgetOptions, getPlotterPublicWidgetOptions, getRadioPublicWidgetOptions, getSorterPublicWidgetOptions, getTablePublicWidgetOptions, getUpgradedWidgetOptions, getWidgetIdsFromContent, getWidgetIdsFromContentByType, gradedGroupWidgetLogic as gradedGroupLogic, gradedGroupSetWidgetLogic as gradedGroupSetLogic, grapherWidgetLogic as grapherLogic, groupWidgetLogic as groupLogic, iframeWidgetLogic as iframeLogic, imageWidgetLogic as imageLogic, inputNumberWidgetLogic as inputNumberLogic, interactionWidgetLogic as interactionLogic, interactiveGraphWidgetLogic as interactiveGraphLogic, isFailure, isSuccess, labelImageWidgetLogic as labelImageLogic, libVersion, lockedFigureColorNames, lockedFigureColors, lockedFigureFillStyles, mapObject, matcherWidgetLogic as matcherLogic, matrixWidgetLogic as matrixLogic, measurerWidgetLogic as measurerLogic, numberLineWidgetLogic as numberLineLogic, numericInputWidgetLogic as numericInputLogic, ordererWidgetLogic as ordererLogic, parseAndMigratePerseusArticle, parseAndMigratePerseusItem, parsePerseusItem, passageWidgetLogic as passageLogic, passageRefWidgetLogic as passageRefLogic, passageRefTargetWidgetLogic as passageRefTargetLogic, phetSimulationWidgetLogic as phetSimulationLogic, plotterWidgetLogic as plotterLogic, plotterPlotTypes, pluck, pythonProgramWidgetLogic as pythonProgramLogic, radioWidgetLogic as radioLogic, random, seededRNG, shuffle, shuffleMatcher, sorterWidgetLogic as sorterLogic, splitPerseusItem, tableWidgetLogic as tableLogic, upgradeWidgetInfoToLatestVersion, videoWidgetLogic as videoLogic };
//# sourceMappingURL=index.js.map
