/**
 * The Perseus "data schema" file.
 *
 * This file, and the types in it, represents the "data schema" that Perseus
 * uses. The @khanacademy/perseus-editor package edits and produces objects
 * that conform to the types in this file. Similarly, the top-level renderers
 * in @khanacademy/perseus, consume objects that conform to these types.
 *
 * WARNING: This file should not import any types from elsewhere so that it is
 * easy to reason about changes that alter the Perseus schema. This helps
 * ensure that it is not changed accidentally when upgrading a dependant
 * package or other part of Perseus code. Note that TypeScript does type
 * checking via something called "structural typing". This means that as long
 * as the shape of a type matches, the name it goes by doesn't matter. As a
 * result, a `Coord` type that looks like this `[x: number, y: number]` is
 * _identical_, in TypeScript's eyes, to this `Vector2` type `[x: number, y:
 * number]`. Also, with tuples, the labels for each entry is ignored, so `[x:
 * number, y: number]` is compatible with `[min: number, max: number]`. The
 * labels are for humans, not TypeScript. :)
 *
 * If you make changes to types in this file, be very sure that:
 *
 *   a) the changes are backwards compatible. If they are not, old data from
 *      previous versions of the "schema" could become unrenderable, or worse,
 *      introduce hard-to-diagnose bugs.
 *   b) the parsing code (`util/parse-perseus-json/`) is updated to handle
 *      the new format _as well as_ the old format.
 */
export type Coord = [x: number, y: number];
export type Interval = [min: number, max: number];
export type Vector2 = Coord;
export type Range = Interval;
export type Size = [width: number, height: number];
export type CollinearTuple = [Vector2, Vector2];
export type ShowSolutions = "all" | "selected" | "none";
/**
 * A utility type that constructs a widget map from a "registry interface".
 * The keys of the registry should be the widget type (aka, "categorizer" or
 * "radio", etc) and the value should be the option type stored in the value
 * of the map.
 *
 * You can think of this as a type that generates another type. We use
 * "registry interfaces" as a way to keep a set of widget types to their data
 * type in several places in Perseus. This type then allows us to generate a
 * map type that maps a widget id to its data type and keep strong typing by
 * widget id.
 *
 * For example, given a fictitious registry such as this:
 *
 * ```
 * interface DummyRegistry {
 *     categorizer: { categories: ReadonlyArray<string> };
 *     dropdown: { choices: ReadonlyArray<string> }:
 * }
 * ```
 *
 * If we create a DummyMap using this helper:
 *
 * ```
 * type DummyMap = MakeWidgetMap<DummyRegistry>;
 * ```
 *
 * We'll get a map that looks like this:
 *
 * ```
 * type DummyMap = {
 *     `categorizer ${number}`: { categories: ReadonlyArray<string> };
 *     `dropdown ${number}`: { choices: ReadonlyArray<string> };
 * }
 * ```
 *
 * We use interfaces for the registries so that they can be extended in cases
 * where the consuming app brings along their own widgets. Interfaces in
 * TypeScript are always open (ie. you can extend them) whereas types aren't.
 */
export type MakeWidgetMap<TRegistry> = {
    [Property in keyof TRegistry as `${Property & string} ${number}`]: TRegistry[Property];
};
/**
 * Our core set of Perseus widgets.
 *
 * This interface is the basis for "registering" all Perseus widget types.
 * There should be one key/value pair for each supported widget. If you create
 * a new widget, an entry should be added to this interface. Note that this
 * only registers the widget options type, you'll also need to register the
 * widget so that it's available at runtime (@see
 * {@link file://./widgets.ts#registerWidget}).
 *
 * Importantly, the key should be the name that is used in widget IDs. For most
 * widgets that is the same as the widget option's `type` field. In cases where
 * a widget has been deprecated and replaced with the deprecated-standin
 * widget, it should be the original widget type!
 *
 * If you define the widget outside of this package, you can still add the new
 * widget to this interface by writing the following in that package that
 * contains the widget. TypeScript will merge that definition of the
 * `PerseusWidgets` with the one defined below.
 *
 * ```typescript
 * declare module "@khanacademy/perseus-core" {
 *     interface PerseusWidgetTypes {
 *         // A new widget
 *         "new-awesomeness": MyAwesomeNewWidget;
 *
 *         // A deprecated widget
 *         "super-old-widget": DeprecatedStandinWidget;
 *     }
 * }
 *
 * // The new widget's options definition
 * type MyAwesomeNewWidget = WidgetOptions<'new-awesomeness', MyAwesomeNewWidgetOptions>;
 *
 * // The deprecated widget's options definition
 * type SuperOldWidget = WidgetOptions<'super-old-widget', object>;
 * ```
 *
 * This interface can be extended through the magic of TypeScript "Declaration
 * merging". Specifically, we augment this module and extend this interface.
 *
 * @see {@link https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation}
 */
export interface PerseusWidgetTypes {
    categorizer: CategorizerWidget;
    "cs-program": CSProgramWidget;
    definition: DefinitionWidget;
    dropdown: DropdownWidget;
    explanation: ExplanationWidget;
    expression: ExpressionWidget;
    grapher: GrapherWidget;
    "graded-group-set": GradedGroupSetWidget;
    "graded-group": GradedGroupWidget;
    group: GroupWidget;
    iframe: IFrameWidget;
    image: ImageWidget;
    "input-number": InputNumberWidget;
    interaction: InteractionWidget;
    "interactive-graph": InteractiveGraphWidget;
    "label-image": LabelImageWidget;
    matcher: MatcherWidget;
    matrix: MatrixWidget;
    measurer: MeasurerWidget;
    "molecule-renderer": MoleculeRendererWidget;
    "number-line": NumberLineWidget;
    "numeric-input": NumericInputWidget;
    orderer: OrdererWidget;
    "passage-ref-target": RefTargetWidget;
    "passage-ref": PassageRefWidget;
    passage: PassageWidget;
    "phet-simulation": PhetSimulationWidget;
    "python-program": PythonProgramWidget;
    plotter: PlotterWidget;
    radio: RadioWidget;
    sorter: SorterWidget;
    table: TableWidget;
    video: VideoWidget;
    "lights-puzzle": DeprecatedStandinWidget;
    sequence: DeprecatedStandinWidget;
    simulator: DeprecatedStandinWidget;
    transformer: DeprecatedStandinWidget;
}
/**
 * A map of widget IDs to widget options. This is most often used as the type
 * for a set of widgets defined in a `PerseusItem` but can also be useful to
 * represent a function parameter where only `widgets` from a `PerseusItem` are
 * needed. Today Widget IDs are made up of the widget type and an incrementing
 * integer (eg. `interactive-graph 1` or `radio 3`). It is suggested to avoid
 * reading/parsing the widget id to derive any information from it, except in
 * the case of this map.
 *
 * @see {@link PerseusWidgetTypes} additional widgets can be added to this map type
 * by augmenting the PerseusWidgetTypes with new widget types!
 */
export type PerseusWidgetsMap = MakeWidgetMap<PerseusWidgetTypes>;
/**
 * PerseusWidget is a union of all the different types of widget options that
 * Perseus knows about.
 *
 * Thanks to it being based on PerseusWidgetTypes interface, this union is
 * automatically extended to include widgets used in tests without those widget
 * option types seeping into our production types.
 *
 * @see MockWidget for an example
 */
export type PerseusWidget = PerseusWidgetTypes[keyof PerseusWidgetTypes];
/**
 * A "PerseusItem" is a classic Perseus item. It is rendered by the
 * `ServerItemRenderer` and the layout is pre-set.
 *
 * To render more complex Perseus items, see the `Item` type in the multi item
 * area.
 */
export type PerseusItem = {
    question: PerseusRenderer;
    hints: ReadonlyArray<Hint>;
    answerArea: PerseusAnswerArea | null | undefined;
    /**
     * The version of the item.
     * @deprecated Not used.
     */
    itemDataVersion: any;
    /**
     * @deprecated Superseded by per-widget answers.
     */
    answer: any;
};
/**
 * A "PerseusArticle" is an item that is meant to be rendered as an article.
 * This item is never scored and is rendered by the `ArticleRenderer`.
 */
export type PerseusArticle = PerseusRenderer | ReadonlyArray<PerseusRenderer>;
export type Version = {
    major: number;
    minor: number;
};
export type PerseusRenderer = {
    /**
     * Translatable Markdown content to be rendered.  May include references to
     * widgets (as [[â˜ƒ widgetName]]) or images (as ![image text](imageUrl)).
     * For each image found in this content, there can be an entry in the
     * `images` dict (below) with the key being the image's url which defines
     * additional attributes for the image.
     */
    content: string;
    /**
     * A dictionary of {[widgetName]: Widget} to be referenced from the content
     * field.
     */
    widgets: PerseusWidgetsMap;
    /**
     * Formerly used in the PerseusGradedGroup widget.  A list of "tags" that
     * are keys that represent other content in the system.  Not rendered to
     * the user. NOTE: perseus_data.go says this is required even though it
     * isn't necessary.
     * @deprecated
     */
    metadata?: any;
    /**
     * A dictionary of {[imageUrl]: PerseusImageDetail}.
     */
    images: {
        [imageUrl: string]: PerseusImageDetail;
    };
};
export type Hint = PerseusRenderer & {
    /**
     * When `true`, causes the previous hint to be replaced with this hint when
     * displayed. When `false`, the previous hint remains visible when this one
     * is displayed. This allows for hints that build upon each other.
     */
    replace?: boolean;
};
export type PerseusImageDetail = {
    width: number;
    height: number;
};
export declare const ItemExtras: readonly ["calculator", "chi2Table", "financialCalculatorMonthlyPayment", "financialCalculatorTotalAmount", "financialCalculatorTimeToPayOff", "periodicTable", "periodicTableWithKey", "tTable", "zTable"];
export type PerseusAnswerArea = Record<(typeof ItemExtras)[number], boolean>;
/**
 * The type representing the common structure of all widget's options. The
 * `Options` generic type represents the widget-specific option data.
 */
export type WidgetOptions<Type extends string, Options> = {
    type: Type;
    static?: boolean;
    graded?: boolean;
    alignment?: string;
    options: Options;
    key?: number | null;
    version?: Version;
};
export type CategorizerWidget = WidgetOptions<'categorizer', PerseusCategorizerWidgetOptions>;
export type CSProgramWidget = WidgetOptions<'cs-program', PerseusCSProgramWidgetOptions>;
export type DefinitionWidget = WidgetOptions<'definition', PerseusDefinitionWidgetOptions>;
export type DropdownWidget = WidgetOptions<'dropdown', PerseusDropdownWidgetOptions>;
export type ExplanationWidget = WidgetOptions<'explanation', PerseusExplanationWidgetOptions>;
export type ExpressionWidget = WidgetOptions<'expression', PerseusExpressionWidgetOptions>;
export type GradedGroupSetWidget = WidgetOptions<'graded-group-set', PerseusGradedGroupSetWidgetOptions>;
export type GradedGroupWidget = WidgetOptions<'graded-group', PerseusGradedGroupWidgetOptions>;
export type GrapherWidget = WidgetOptions<'grapher', PerseusGrapherWidgetOptions>;
export type GroupWidget = WidgetOptions<'group', PerseusGroupWidgetOptions>;
export type IFrameWidget = WidgetOptions<'iframe', PerseusIFrameWidgetOptions>;
export type ImageWidget = WidgetOptions<'image', PerseusImageWidgetOptions>;
export type InteractionWidget = WidgetOptions<'interaction', PerseusInteractionWidgetOptions>;
export type InteractiveGraphWidget = WidgetOptions<'interactive-graph', PerseusInteractiveGraphWidgetOptions>;
export type LabelImageWidget = WidgetOptions<'label-image', PerseusLabelImageWidgetOptions>;
export type MatcherWidget = WidgetOptions<'matcher', PerseusMatcherWidgetOptions>;
export type MatrixWidget = WidgetOptions<'matrix', PerseusMatrixWidgetOptions>;
export type MeasurerWidget = WidgetOptions<'measurer', PerseusMeasurerWidgetOptions>;
export type NumberLineWidget = WidgetOptions<'number-line', PerseusNumberLineWidgetOptions>;
export type NumericInputWidget = WidgetOptions<'numeric-input', PerseusNumericInputWidgetOptions>;
export type OrdererWidget = WidgetOptions<'orderer', PerseusOrdererWidgetOptions>;
export type PassageRefWidget = WidgetOptions<'passage-ref', PerseusPassageRefWidgetOptions>;
export type PassageWidget = WidgetOptions<'passage', PerseusPassageWidgetOptions>;
export type PhetSimulationWidget = WidgetOptions<'phet-simulation', PerseusPhetSimulationWidgetOptions>;
export type PlotterWidget = WidgetOptions<'plotter', PerseusPlotterWidgetOptions>;
export type PythonProgramWidget = WidgetOptions<'python-program', PerseusPythonProgramWidgetOptions>;
export type RadioWidget = WidgetOptions<'radio', PerseusRadioWidgetOptions>;
export type SorterWidget = WidgetOptions<'sorter', PerseusSorterWidgetOptions>;
export type TableWidget = WidgetOptions<'table', PerseusTableWidgetOptions>;
export type InputNumberWidget = WidgetOptions<'input-number', PerseusInputNumberWidgetOptions>;
export type MoleculeRendererWidget = WidgetOptions<'molecule-renderer', PerseusMoleculeRendererWidgetOptions>;
export type RefTargetWidget = WidgetOptions<'passage-ref-target', PerseusPassageRefTargetWidgetOptions>;
export type VideoWidget = WidgetOptions<'video', PerseusVideoWidgetOptions>;
export type DeprecatedStandinWidget = WidgetOptions<'deprecated-standin', object>;
/**
 * A background image applied to various widgets.
 */
export type PerseusImageBackground = {
    url: string | null | undefined;
    width?: number;
    height?: number;
    top?: number;
    left?: number;
    scale?: number;
    bottom?: number;
};
/**
 * The type of markings to display on the graph.
 * - axes: shows the axes without the gride lines
 * - graph: shows the axes and the grid lines
 * - grid: shows only the grid lines
 * - none: shows no markings
 */
export type MarkingsType = "axes" | "graph" | "grid" | "none";
export type PerseusCategorizerWidgetOptions = {
    items: ReadonlyArray<string>;
    categories: ReadonlyArray<string>;
    randomizeItems: boolean;
    static: boolean;
    values: ReadonlyArray<number>;
    highlightLint?: boolean;
    linterContext?: PerseusLinterContext;
};
export type PerseusLinterContext = {
    contentType: string;
    paths: ReadonlyArray<string>;
    stack: ReadonlyArray<string>;
};
export type PerseusDefinitionWidgetOptions = {
    togglePrompt: string;
    definition: string;
    static: boolean;
};
export type PerseusDropdownWidgetOptions = {
    choices: ReadonlyArray<PerseusDropdownChoice>;
    placeholder: string;
    static: boolean;
    visibleLabel?: string;
    ariaLabel?: string;
};
export type PerseusDropdownChoice = {
    content: string;
    correct: boolean;
};
export type PerseusExplanationWidgetOptions = {
    showPrompt: string;
    hidePrompt: string;
    explanation: string;
    widgets: PerseusWidgetsMap;
    static: boolean;
};
export type LegacyButtonSets = ReadonlyArray<"basic" | "basic+div" | "trig" | "prealgebra" | "logarithms" | "basic relations" | "advanced relations" | "scientific">;
export type PerseusExpressionWidgetOptions = {
    answerForms: ReadonlyArray<PerseusExpressionAnswerForm>;
    buttonSets: LegacyButtonSets;
    functions: ReadonlyArray<string>;
    times: boolean;
    visibleLabel?: string;
    ariaLabel?: string;
    buttonsVisible?: "always" | "never" | "focused";
};
export declare const PerseusExpressionAnswerFormConsidered: readonly ["correct", "wrong", "ungraded"];
export type PerseusExpressionAnswerForm = {
    value: string;
    form: boolean;
    simplify: boolean;
    considered: (typeof PerseusExpressionAnswerFormConsidered)[number];
    key?: string;
};
export type PerseusGradedGroupWidgetOptions = {
    title: string;
    hasHint?: boolean | null | undefined;
    hint?: PerseusRenderer | null | undefined;
    content: string;
    widgets: PerseusWidgetsMap;
    widgetEnabled?: boolean | null | undefined;
    immutableWidgets?: boolean | null | undefined;
    images: {
        [key: string]: PerseusImageDetail;
    };
};
export type PerseusGradedGroupSetWidgetOptions = {
    gradedGroups: ReadonlyArray<PerseusGradedGroupWidgetOptions>;
};
export type GraphRange = [
    x: [min: number, max: number],
    y: [min: number, max: number]
];
export type GrapherAnswerTypes = {
    type: "absolute_value";
    coords: null | [vertex: Coord, secondPoint: Coord];
} | {
    type: "exponential";
    asymptote: [Coord, Coord];
    coords: null | [Coord, Coord];
} | {
    type: "linear";
    coords: null | [Coord, Coord];
} | {
    type: "logarithm";
    asymptote: [Coord, Coord];
    coords: null | [Coord, Coord];
} | {
    type: "quadratic";
    coords: null | [vertex: Coord, secondPoint: Coord];
} | {
    type: "sinusoid";
    coords: null | [Coord, Coord];
} | {
    type: "tangent";
    coords: null | [Coord, Coord];
};
export type PerseusGrapherWidgetOptions = {
    availableTypes: ReadonlyArray<"absolute_value" | "exponential" | "linear" | "logarithm" | "quadratic" | "sinusoid" | "tangent">;
    correct: GrapherAnswerTypes;
    graph: {
        backgroundImage: {
            bottom?: number;
            height?: number;
            left?: number;
            scale?: number;
            url?: string | null | undefined;
            width?: number;
        };
        box?: [number, number];
        editableSettings?: ReadonlyArray<"graph" | "snap" | "image" | "measure">;
        gridStep?: [number, number];
        labels: [string, string];
        markings: MarkingsType;
        range: GraphRange;
        rulerLabel: "";
        rulerTicks: number;
        showProtractor?: boolean;
        showRuler?: boolean;
        showTooltips?: boolean;
        snapStep?: [number, number];
        step: [number, number];
        valid?: boolean | string;
    };
};
export type PerseusGroupWidgetOptions = PerseusRenderer;
export type PerseusImageWidgetOptions = {
    title?: string;
    caption?: string;
    alt?: string;
    backgroundImage: PerseusImageBackground;
    static?: boolean;
    labels?: ReadonlyArray<PerseusImageLabel>;
    range?: [Interval, Interval];
    box?: Size;
};
export type PerseusImageLabel = {
    content: string;
    alignment: string;
    coordinates: ReadonlyArray<number>;
};
export type PerseusInteractiveGraphWidgetOptions = {
    step: [number, number];
    gridStep?: [x: number, y: number];
    snapStep?: [x: number, y: number];
    backgroundImage?: PerseusImageBackground;
    /**
     * The type of markings to display on the graph.
     */
    markings: MarkingsType;
    labels?: ReadonlyArray<string>;
    showProtractor: boolean;
    /**
     * Whether to show the Ruler tool overlayed on top of the graph.
     * @deprecated - no longer used by the InteractiveGraph widget. The
     * property is kept on this type to prevent its accidental reuse in future
     * features, since it may appear in production data.
     */
    showRuler?: boolean;
    showTooltips?: boolean;
    /**
     * The unit to show on the ruler.  e.g. "mm", "cm",  "m", "km", "in", "ft",
     * "yd", "mi".
     * @deprecated - no longer used by the InteractiveGraph widget. The
     * property is kept on this type to prevent its accidental reuse in future
     * features, since it may appear in production data.
     */
    rulerLabel?: string;
    /**
     * How many ticks to show on the ruler.  e.g. 1, 2, 4, 8, 10, 16. Must be
     * an integer.
     * @deprecated - no longer used by the InteractiveGraph widget. The
     * property is kept on this type to prevent its accidental reuse in future
     * features, since it may appear in production data.
     */
    rulerTicks?: number;
    range: GraphRange;
    graph: PerseusGraphType;
    correct: PerseusGraphType;
    lockedFigures?: ReadonlyArray<LockedFigure>;
    fullGraphAriaLabel?: string;
    fullGraphAriaDescription?: string;
};
export declare const lockedFigureColorNames: readonly ["blue", "green", "grayH", "purple", "pink", "orange", "red"];
export type LockedFigureColor = (typeof lockedFigureColorNames)[number];
export declare const lockedFigureColors: Record<LockedFigureColor, string>;
export type LockedFigure = LockedPointType | LockedLineType | LockedVectorType | LockedEllipseType | LockedPolygonType | LockedFunctionType | LockedLabelType;
export type LockedFigureType = LockedFigure["type"];
export type LockedLineStyle = "solid" | "dashed";
export type LockedPointType = {
    type: "point";
    coord: Coord;
    color: LockedFigureColor;
    filled: boolean;
    labels?: LockedLabelType[];
    ariaLabel?: string;
};
export type LockedLineType = {
    type: "line";
    kind: "line" | "ray" | "segment";
    points: [point1: LockedPointType, point2: LockedPointType];
    color: LockedFigureColor;
    lineStyle: LockedLineStyle;
    showPoint1: boolean;
    showPoint2: boolean;
    labels?: LockedLabelType[];
    ariaLabel?: string;
};
export type LockedVectorType = {
    type: "vector";
    points: [tail: Coord, tip: Coord];
    color: LockedFigureColor;
    labels?: LockedLabelType[];
    ariaLabel?: string;
};
export type LockedFigureFillType = "none" | "white" | "translucent" | "solid";
export declare const lockedFigureFillStyles: Record<LockedFigureFillType, number>;
export type LockedEllipseType = {
    type: "ellipse";
    center: Coord;
    radius: [x: number, y: number];
    angle: number;
    color: LockedFigureColor;
    fillStyle: LockedFigureFillType;
    strokeStyle: LockedLineStyle;
    labels?: LockedLabelType[];
    ariaLabel?: string;
};
export type LockedPolygonType = {
    type: "polygon";
    points: ReadonlyArray<Coord>;
    color: LockedFigureColor;
    showVertices: boolean;
    fillStyle: LockedFigureFillType;
    strokeStyle: LockedLineStyle;
    labels?: LockedLabelType[];
    ariaLabel?: string;
};
export type LockedFunctionType = {
    type: "function";
    color: LockedFigureColor;
    strokeStyle: LockedLineStyle;
    equation: string;
    directionalAxis: "x" | "y";
    domain?: [min: number | null, max: number | null];
    labels?: LockedLabelType[];
    ariaLabel?: string;
};
export type LockedLabelType = {
    type: "label";
    coord: Coord;
    text: string;
    color: LockedFigureColor;
    size: "small" | "medium" | "large";
};
export type PerseusGraphType = PerseusGraphTypeAngle | PerseusGraphTypeCircle | PerseusGraphTypeLinear | PerseusGraphTypeLinearSystem | PerseusGraphTypeNone | PerseusGraphTypePoint | PerseusGraphTypePolygon | PerseusGraphTypeQuadratic | PerseusGraphTypeRay | PerseusGraphTypeSegment | PerseusGraphTypeSinusoid;
type PerseusGraphTypeCommon = {
    coord?: Coord;
};
export type PerseusGraphTypeAngle = {
    type: "angle";
    showAngles?: boolean;
    allowReflexAngles?: boolean;
    angleOffsetDeg?: number;
    snapDegrees?: number;
    match?: "congruent";
    coords?: [Coord, Coord, Coord] | null;
    startCoords?: [Coord, Coord, Coord];
};
export type PerseusGraphTypeCircle = {
    type: "circle";
    center?: Coord;
    radius?: number;
    startCoords?: {
        center: Coord;
        radius: number;
    };
} & PerseusGraphTypeCommon;
export type PerseusGraphTypeLinear = {
    type: "linear";
    coords?: CollinearTuple | null;
    startCoords?: CollinearTuple;
} & PerseusGraphTypeCommon;
export type PerseusGraphTypeLinearSystem = {
    type: "linear-system";
    coords?: CollinearTuple[] | null;
    startCoords?: CollinearTuple[];
} & PerseusGraphTypeCommon;
export type PerseusGraphTypeNone = {
    type: "none";
};
export type PerseusGraphTypePoint = {
    type: "point";
    numPoints?: number | "unlimited";
    coords?: ReadonlyArray<Coord> | null;
    startCoords?: ReadonlyArray<Coord>;
} & PerseusGraphTypeCommon;
export type PerseusGraphTypePolygon = {
    type: "polygon";
    numSides?: number | "unlimited";
    showAngles?: boolean;
    showSides?: boolean;
    snapTo?: "grid" | "angles" | "sides";
    match?: "similar" | "congruent" | "approx" | "exact";
    coords?: ReadonlyArray<Coord> | null;
    startCoords?: ReadonlyArray<Coord>;
} & PerseusGraphTypeCommon;
export type PerseusGraphTypeQuadratic = {
    type: "quadratic";
    coords?: [Coord, Coord, Coord] | null;
    startCoords?: [Coord, Coord, Coord];
} & PerseusGraphTypeCommon;
export type PerseusGraphTypeSegment = {
    type: "segment";
    numSegments?: number;
    coords?: CollinearTuple[] | null;
    startCoords?: CollinearTuple[];
} & PerseusGraphTypeCommon;
export type PerseusGraphTypeSinusoid = {
    type: "sinusoid";
    coords?: ReadonlyArray<Coord> | null;
    startCoords?: ReadonlyArray<Coord>;
} & PerseusGraphTypeCommon;
export type PerseusGraphTypeRay = {
    type: "ray";
    coords?: CollinearTuple | null;
    startCoords?: CollinearTuple;
} & PerseusGraphTypeCommon;
type AngleGraphCorrect = {
    type: "angle";
    allowReflexAngles: boolean;
    match?: "congruent";
    coords: [Coord, Coord, Coord];
};
type CircleGraphCorrect = {
    type: "circle";
    center: Coord;
    radius: number;
};
type LinearGraphCorrect = {
    type: "linear";
    coords: CollinearTuple;
};
type LinearSystemGraphCorrect = {
    type: "linear-system";
    coords: [CollinearTuple, CollinearTuple];
};
type NoneGraphCorrect = {
    type: "none";
};
type PointGraphCorrect = {
    type: "point";
    coords: ReadonlyArray<Coord>;
};
type PolygonGraphCorrect = {
    type: "polygon";
    match: "similar" | "congruent" | "approx";
    coords: ReadonlyArray<Coord>;
};
type QuadraticGraphCorrect = {
    type: "quadratic";
    coords: [Coord, Coord, Coord];
};
type SegmentGraphCorrect = {
    type: "segment";
    coords: CollinearTuple[];
};
type SinusoidGraphCorrect = {
    type: "sinusoid";
    coords: CollinearTuple;
};
type RayGraphCorrect = {
    type: "ray";
    coords: CollinearTuple;
};
export type PerseusGraphCorrectType = AngleGraphCorrect | CircleGraphCorrect | LinearGraphCorrect | LinearSystemGraphCorrect | NoneGraphCorrect | PointGraphCorrect | PolygonGraphCorrect | QuadraticGraphCorrect | RayGraphCorrect | SegmentGraphCorrect | SinusoidGraphCorrect;
export type PerseusLabelImageWidgetOptions = {
    choices: ReadonlyArray<string>;
    imageUrl: string;
    imageAlt: string;
    imageHeight: number;
    imageWidth: number;
    markers: ReadonlyArray<PerseusLabelImageMarker>;
    hideChoicesFromInstructions: boolean;
    multipleAnswers: boolean;
    static: boolean;
};
export type PerseusLabelImageMarker = {
    answers: ReadonlyArray<string>;
    label: string;
    x: number;
    y: number;
};
export type PerseusMatcherWidgetOptions = {
    labels: ReadonlyArray<string>;
    left: ReadonlyArray<string>;
    right: ReadonlyArray<string>;
    orderMatters: boolean;
    padding: boolean;
};
export type PerseusMatrixWidgetAnswers = ReadonlyArray<ReadonlyArray<number>>;
export type PerseusMatrixWidgetOptions = {
    prefix?: string | undefined;
    suffix?: string | undefined;
    answers: PerseusMatrixWidgetAnswers;
    cursorPosition?: ReadonlyArray<number> | undefined;
    matrixBoardSize: ReadonlyArray<number>;
    static?: boolean | undefined;
};
export type PerseusMeasurerWidgetOptions = {
    image: PerseusImageBackground;
    showProtractor: boolean;
    showRuler: boolean;
    rulerLabel: string;
    rulerTicks: number;
    rulerPixels: number;
    rulerLength: number;
    box: [number, number];
    static: boolean;
};
export type MathFormat = "integer" | "mixed" | "improper" | "proper" | "decimal" | "percent" | "pi";
export type PerseusNumericInputAnswerForm = {
    simplify: "required" | "correct" | "enforced" | "optional" | null | undefined;
    name: MathFormat;
};
export type PerseusNumericInputWidgetOptions = {
    answers: ReadonlyArray<PerseusNumericInputAnswer>;
    labelText?: string | undefined;
    size: string;
    coefficient: boolean;
    rightAlign?: boolean;
    static: boolean;
    answerForms?: ReadonlyArray<PerseusNumericInputAnswerForm>;
};
export type PerseusNumericInputAnswer = {
    message: string;
    value?: number | null;
    status: string;
    answerForms?: ReadonlyArray<MathFormat>;
    strict: boolean;
    maxError: number | null | undefined;
    simplify: string | null | undefined;
};
export type PerseusNumberLineWidgetOptions = {
    range: ReadonlyArray<number>;
    labelRange: ReadonlyArray<number | null>;
    labelStyle: string;
    labelTicks: boolean;
    isTickCtrl?: boolean | null | undefined;
    divisionRange: ReadonlyArray<number>;
    numDivisions: number | null | undefined;
    snapDivisions: number;
    tickStep: number | null | undefined;
    correctRel: string | null | undefined;
    correctX: number | null;
    initialX: number | null | undefined;
    showTooltips?: boolean;
    static: boolean;
};
export type PerseusOrdererWidgetOptions = {
    options: ReadonlyArray<PerseusRenderer>;
    correctOptions: ReadonlyArray<PerseusRenderer>;
    otherOptions: ReadonlyArray<PerseusRenderer>;
    height: "normal" | "auto";
    layout: "horizontal" | "vertical";
};
export type PerseusPassageWidgetOptions = {
    footnotes: string;
    passageText: string;
    passageTitle: string;
    showLineNumbers: boolean;
    static: boolean;
};
export type PerseusPassageRefWidgetOptions = {
    passageNumber: number;
    referenceNumber: number;
    summaryText?: string;
};
export declare const plotterPlotTypes: readonly ["bar", "line", "pic", "histogram", "dotplot"];
export type PlotType = (typeof plotterPlotTypes)[number];
export type PerseusPlotterWidgetOptions = {
    labels: ReadonlyArray<string>;
    categories: ReadonlyArray<string>;
    type: PlotType;
    maxY: number;
    scaleY: number;
    labelInterval: number | null | undefined;
    snapsPerLine: number;
    starting: ReadonlyArray<number>;
    correct: ReadonlyArray<number>;
    picUrl: string | null | undefined;
    picSize: number | null | undefined;
    picBoxHeight: number | null | undefined;
    plotDimensions: ReadonlyArray<number>;
};
export type PerseusRadioWidgetOptions = {
    choices: ReadonlyArray<PerseusRadioChoice>;
    hasNoneOfTheAbove?: boolean;
    countChoices?: boolean;
    randomize?: boolean;
    multipleSelect?: boolean;
    deselectEnabled?: boolean;
    onePerLine?: boolean;
    displayCount?: any;
    noneOfTheAbove?: false;
};
export type PerseusRadioChoice = {
    content: string;
    clue?: string;
    correct?: boolean;
    isNoneOfTheAbove?: boolean;
    widgets?: PerseusWidgetsMap;
};
export type PerseusSorterWidgetOptions = {
    correct: ReadonlyArray<string>;
    padding: boolean;
    layout: "horizontal" | "vertical";
};
export type PerseusTableWidgetOptions = {
    headers: ReadonlyArray<string>;
    rows: number;
    columns: number;
    answers: ReadonlyArray<ReadonlyArray<string>>;
};
export type PerseusInteractionWidgetOptions = {
    graph: PerseusInteractionGraph;
    elements: ReadonlyArray<PerseusInteractionElement>;
    static: boolean;
};
export type PerseusInteractionGraph = {
    editableSettings?: ReadonlyArray<"canvas" | "graph">;
    box: Size;
    labels: ReadonlyArray<string>;
    range: [Interval, Interval];
    gridStep: [number, number];
    /**
     * The type of markings to display on the graph.
     */
    markings: MarkingsType;
    snapStep?: [number, number];
    valid?: boolean | string;
    backgroundImage?: PerseusImageBackground;
    showProtractor?: boolean;
    showRuler?: boolean;
    rulerLabel?: string;
    rulerTicks?: number;
    tickStep: [number, number];
};
export type PerseusInteractionElement = {
    type: "function";
    key: string;
    options: PerseusInteractionFunctionElementOptions;
} | {
    type: "label";
    key: string;
    options: PerseusInteractionLabelElementOptions;
} | {
    type: "line";
    key: string;
    options: PerseusInteractionLineElementOptions;
} | {
    type: "movable-line";
    key: string;
    options: PerseusInteractionMovableLineElementOptions;
} | {
    type: "movable-point";
    key: string;
    options: PerseusInteractionMovablePointElementOptions;
} | {
    type: "parametric";
    key: string;
    options: PerseusInteractionParametricElementOptions;
} | {
    type: "point";
    key: string;
    options: PerseusInteractionPointElementOptions;
} | {
    type: "rectangle";
    key: string;
    options: PerseusInteractionRectangleElementOptions;
};
export type PerseusInteractionFunctionElementOptions = {
    value: string;
    funcName: string;
    rangeMin: string;
    rangeMax: string;
    color: string;
    strokeDasharray: string;
    strokeWidth: number;
};
export type PerseusInteractionLabelElementOptions = {
    label: string;
    color: string;
    coordX: string;
    coordY: string;
};
export type PerseusInteractionLineElementOptions = {
    color: string;
    startX: string;
    startY: string;
    endX: string;
    endY: string;
    strokeDasharray: string;
    strokeWidth: number;
    arrows: string;
};
export type PerseusInteractionMovableLineElementOptions = {
    startX: string;
    startY: string;
    startSubscript: number;
    endX: string;
    endY: string;
    endSubscript: number;
    constraint: string;
    snap: number;
    constraintFn: string;
    constraintXMin: string;
    constraintXMax: string;
    constraintYMin: string;
    constraintYMax: string;
};
export type PerseusInteractionMovablePointElementOptions = {
    startX: string;
    startY: string;
    varSubscript: number;
    constraint: string;
    snap: number;
    constraintFn: string;
    constraintXMin: string;
    constraintXMax: string;
    constraintYMin: string;
    constraintYMax: string;
};
export type PerseusInteractionParametricElementOptions = {
    x: string;
    y: string;
    rangeMin: string;
    rangeMax: string;
    color: string;
    strokeDasharray: string;
    strokeWidth: number;
};
export type PerseusInteractionPointElementOptions = {
    color: string;
    coordX: string;
    coordY: string;
};
export type PerseusInteractionRectangleElementOptions = {
    color: string;
    coordX: string;
    coordY: string;
    width: string;
    height: string;
};
export type PerseusCSProgramWidgetOptions = {
    programID: string;
    programType?: any;
    settings: ReadonlyArray<PerseusCSProgramSetting>;
    showEditor: boolean;
    showButtons: boolean;
    height: number;
    static: boolean;
};
export type PerseusCSProgramSetting = {
    name: string;
    value: string;
};
export type PerseusPythonProgramWidgetOptions = {
    programID: string;
    height: number;
};
export type PerseusIFrameWidgetOptions = {
    url: string;
    settings?: ReadonlyArray<PerseusCSProgramSetting>;
    width: number | string;
    height: number | string;
    allowFullScreen: boolean;
    allowTopNavigation?: boolean;
    static: boolean;
};
export type PerseusPhetSimulationWidgetOptions = {
    url: string;
    description: string;
};
export type PerseusVideoWidgetOptions = {
    location: string;
    static?: boolean;
};
export type PerseusInputNumberWidgetOptions = {
    answerType?: "number" | "decimal" | "integer" | "rational" | "improper" | "mixed" | "percent" | "pi";
    inexact?: boolean;
    maxError?: number | string;
    rightAlign?: boolean;
    simplify: "required" | "optional" | "enforced";
    size: "normal" | "small";
    value: string | number;
    customKeypad?: boolean;
};
export type PerseusMoleculeRendererWidgetOptions = {
    widgetId: string;
    rotationAngle?: number;
    smiles?: string;
};
export type PerseusPassageRefTargetWidgetOptions = {
    content: string;
};
export type PerseusWidgetOptions = PerseusCategorizerWidgetOptions | PerseusCSProgramWidgetOptions | PerseusDefinitionWidgetOptions | PerseusDropdownWidgetOptions | PerseusExplanationWidgetOptions | PerseusExpressionWidgetOptions | PerseusGradedGroupSetWidgetOptions | PerseusGradedGroupWidgetOptions | PerseusIFrameWidgetOptions | PerseusImageWidgetOptions | PerseusInputNumberWidgetOptions | PerseusInteractionWidgetOptions | PerseusInteractiveGraphWidgetOptions | PerseusLabelImageWidgetOptions | PerseusMatcherWidgetOptions | PerseusMatrixWidgetOptions | PerseusMeasurerWidgetOptions | PerseusMoleculeRendererWidgetOptions | PerseusNumberLineWidgetOptions | PerseusNumericInputWidgetOptions | PerseusOrdererWidgetOptions | PerseusPassageRefTargetWidgetOptions | PerseusPassageRefWidgetOptions | PerseusPassageWidgetOptions | PerseusPhetSimulationWidgetOptions | PerseusPlotterWidgetOptions | PerseusRadioWidgetOptions | PerseusSorterWidgetOptions | PerseusTableWidgetOptions | PerseusVideoWidgetOptions;
export {};
